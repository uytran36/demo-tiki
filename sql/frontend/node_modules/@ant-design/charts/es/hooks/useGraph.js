import { useRef, useEffect } from 'react';
import { getGraphSize, processMinimap } from '../graphs/utils';
import { isObject, isString } from '@antv/util';
export default function useInit(graphInstance, config, container) {
    var graphHook = useRef();
    var data = config.data, nodeStyle = config.nodeStyle, nodeAnchorPoints = config.nodeAnchorPoints, nodeType = config.nodeType, edgeType = config.edgeType, edgeStyle = config.edgeStyle, width = config.width, height = config.height, layout = config.layout, minimapCfg = config.minimapCfg, behaviors = config.behaviors, nodeLabelCfg = config.nodeLabelCfg, edgeLabelCfg = config.edgeLabelCfg, _a = config.autoFit, autoFit = _a === void 0 ? true : _a, _b = config.adjustLayout, adjustLayout = _b === void 0 ? true : _b;
    var minimap;
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.changeData(data);
            if (adjustLayout) {
                autoFit ? graphInstance.fitView() : graphInstance.fitCenter();
            }
        }
    }, [data]);
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.getNodes().forEach(function (node) {
                graphInstance.updateItem(node, {
                    type: nodeType,
                    style: nodeStyle,
                    anchorPoints: nodeAnchorPoints,
                    labelCfg: nodeLabelCfg,
                });
            });
        }
    }, [nodeStyle, nodeAnchorPoints, nodeType]);
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.getEdges().forEach(function (edge) {
                graphInstance.updateItem(edge, {
                    type: edgeType,
                    style: edgeStyle,
                    labelCfg: edgeLabelCfg,
                });
            });
        }
    }, [edgeStyle, edgeType]);
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            var graphSize = getGraphSize(width, height, container);
            graphInstance.changeSize(graphSize[0], graphSize[1]);
        }
    }, [container, width, height]);
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.updateLayout(layout);
        }
    }, [layout]);
    useEffect(function () {
        if (!minimapCfg || !graphInstance || graphInstance.destroyed) {
            return;
        }
        if (minimapCfg.show) {
            minimap = processMinimap(minimapCfg, graphInstance);
            minimap === null || minimap === void 0 ? void 0 : minimap.updateCanvas();
        }
        else {
            var pluginMinimap = graphInstance.get('plugins')[0];
            if (pluginMinimap) {
                graphInstance.removePlugin(pluginMinimap);
            }
        }
    }, [minimapCfg]);
    useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            var defaultMode = graphInstance.get('modes').default;
            var removingBehaviors_1 = [];
            defaultMode.forEach(function (be) {
                if (isObject(be)) {
                    removingBehaviors_1.push(be.type);
                }
                else if (isString(be)) {
                    removingBehaviors_1.push(be);
                }
            });
            graphInstance.removeBehaviors(removingBehaviors_1, 'default');
            graphInstance.addBehaviors(behaviors, 'default');
        }
    }, [behaviors]);
    useEffect(function () {
        graphHook.current = graphInstance;
        return function () {
            if (graphInstance && !graphInstance.destroyed) {
                graphInstance.destroy();
                graphInstance = undefined;
            }
        };
    }, []);
    return {
        graphHook: graphHook,
    };
}
