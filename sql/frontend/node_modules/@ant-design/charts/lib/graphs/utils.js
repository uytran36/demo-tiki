"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommonConfig = exports.getStyle = exports.bindStateEvents = exports.getArrowCfg = exports.getCssPadding = exports.bindSourceMapCollapseEvents = exports.getMarkerPosition = exports.processMinimap = exports.renderGraph = exports.getGraphId = exports.bindDefaultEvents = exports.getGraphSize = void 0;
var g6_1 = __importDefault(require("@antv/g6"));
var utils_1 = require("../util/utils");
var constants_1 = require("./constants");
var getGraphSize = function (width, height, container) {
    var CANVAS_WIDTH;
    var CANVAS_HEIGHT;
    if (container && container.current) {
        CANVAS_WIDTH = container.current.offsetWidth;
        CANVAS_HEIGHT = container.current.offsetHeight || 500;
    }
    if ((!width && !CANVAS_WIDTH) || (!height && !CANVAS_HEIGHT)) {
        console.warn('请为 Graph 指定 width 与 height！否则将使用默认值 500 * 500');
        return [500, 500];
    }
    return [width || CANVAS_WIDTH || 500, height || CANVAS_HEIGHT || 500];
};
exports.getGraphSize = getGraphSize;
// 展开&折叠事件
var bindDefaultEvents = function (graph) {
    var onClick = function (e) {
        var item = e.item;
        if (e.target.get('name') === 'collapse-icon') {
            graph.updateItem(item, {
                collapsed: !item.getModel().collapsed,
            });
            graph.layout();
        }
    };
    graph.on('node:click', function (e) {
        onClick(e);
    });
    graph.on('node:touchstart', function (e) {
        onClick(e);
    });
};
exports.bindDefaultEvents = bindDefaultEvents;
var uuid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};
// 同一页面存在多 graph 时需要指定 graphId
var getGraphId = function (graph) {
    if (graph.current) {
        return graph.current;
    }
    graph.current = "IndentedTreeGraph-" + uuid();
    return graph.current;
};
exports.getGraphId = getGraphId;
var renderGraph = function (graph, data, autoFit, adjustLayout) {
    if (adjustLayout === void 0) { adjustLayout = true; }
    var originData = utils_1.deepClone(data);
    graph.data(originData);
    graph.render();
    // 关闭局部刷新，各种 bug
    graph.get('canvas').set('localRefresh', false);
    if (adjustLayout) {
        autoFit ? graph.fitView() : graph.fitCenter();
    }
};
exports.renderGraph = renderGraph;
var processMinimap = function (cfg, graph) {
    if (cfg === void 0) { cfg = {}; }
    if (!graph || graph.destroyed)
        return;
    if (cfg.show) {
        var curMminimapCfg = Object.assign(constants_1.defaultMinimapCfg, cfg);
        var minimap = new g6_1.default.Minimap(__assign({}, curMminimapCfg));
        graph.addPlugin(minimap);
        return minimap;
    }
    return null;
};
exports.processMinimap = processMinimap;
/**
 * min ma
 */
var getMarkerPosition = function (direction, size) {
    if (direction === void 0) { direction = 'right'; }
    var width = size[0], height = size[1];
    var x = 0;
    var y = 0;
    switch (direction) {
        case 'top':
            x = width / 2;
            y = 0;
            break;
        case 'right':
            x = width;
            y = height / 2;
            break;
        case 'bottom':
            x = width / 2;
            y = height;
            break;
        case 'left':
            x = 0;
            y = height / 2;
            break;
    }
    return { x: x, y: y };
};
exports.getMarkerPosition = getMarkerPosition;
var bindSourceMapCollapseEvents = function (graph, fullData) {
    var controlData = utils_1.deepClone(fullData);
    var onClick = function (e) {
        var _a;
        if (e.target.get('name') === 'collapse-icon') {
            var item = e.item;
            var collapsed = item.getModel().collapsed;
            if (!utils_1.isType(collapsed, 'Boolean')) {
                // @ts-ignore
                collapsed = (_a = item._cfg.group
                    .getChildren()
                    .find(function (item) { return item.get('name') === 'main-box'; })) === null || _a === void 0 ? void 0 : _a.attr('defaultCollapsed');
            }
            // @ts-ignore
            var marker = e.item._cfg.group.getChildren().find(function (item) { return item.cfg.type === 'marker'; });
            var _b = (fullData !== null && fullData !== void 0 ? fullData : {}).edges, fullEdges_1 = _b === void 0 ? [] : _b;
            var nodeId = item.getModel().id;
            var targetNodeIds_1 = [];
            var updateItems_1 = [];
            var updateIds_1 = [];
            var getLinkedId_1 = function (currentId) {
                fullEdges_1.forEach(function (edge) {
                    var source = edge.source, target = edge.target;
                    if (source === currentId) {
                        targetNodeIds_1.push(target);
                        getLinkedId_1(target);
                    }
                });
            };
            getLinkedId_1(nodeId);
            if (!collapsed) {
                // collapse
                graph
                    .findAll('node', function (node) { return targetNodeIds_1.includes(node.get('id')); })
                    .forEach(function (node) { return graph.hideItem(node); });
                controlData.nodes.forEach(function (node) {
                    var _a = node.collapsedLevel, collapsedLevel = _a === void 0 ? 0 : _a, id = node.id;
                    if (targetNodeIds_1.includes(id)) {
                        node.collapsedLevel = collapsedLevel + 1;
                    }
                });
            }
            else {
                // expand
                graph
                    .findAll('node', function (node) {
                    var collapsedLevel = controlData.nodes.find(function (item) { return item.id === node.get('id'); }).collapsedLevel;
                    return (targetNodeIds_1.includes(node.get('id')) && (!collapsedLevel || collapsedLevel < 2));
                })
                    .forEach(function (node) { return graph.showItem(node); });
                controlData.nodes.forEach(function (node) {
                    var _a = node.collapsedLevel, collapsedLevel = _a === void 0 ? 0 : _a, id = node.id;
                    if (targetNodeIds_1.includes(id)) {
                        node.collapsedLevel = collapsedLevel - 1;
                    }
                });
            }
            fullEdges_1.forEach(function (edge) {
                var source = edge.source, target = edge.target;
                if (targetNodeIds_1.includes(target)) {
                    updateIds_1.push(source);
                }
            });
            updateIds_1 = Array.from(new Set(updateIds_1));
            updateIds_1.forEach(function (id) {
                updateItems_1.push(graph.find('node', function (node) { return node.get('id') === id; }));
            });
            updateItems_1.forEach(function (nodeItem) {
                graph.updateItem(nodeItem, {
                    collapsed: !nodeItem.getModel().collapsed,
                });
                graph.refreshItem(nodeItem);
            });
        }
    };
    graph.on('node:click', function (e) {
        onClick(e);
    });
    graph.on('node:touchstart', function (e) {
        onClick(e);
    });
};
exports.bindSourceMapCollapseEvents = bindSourceMapCollapseEvents;
/**
 * padding | margin 按 CSS 规则转换
 */
var getCssPadding = function (padding) {
    if (typeof padding === 'number') {
        return [padding, padding, padding, padding];
    }
    var result = [];
    switch (padding.length) {
        case 1:
            result = [padding[0], padding[0], padding[0], padding[0]];
            break;
        case 2:
            result = [padding[0], padding[1], padding[0], padding[1]];
            break;
        case 3:
            result = [padding[0], padding[1], padding[2], padding[1]];
            break;
        case 4:
            result = padding;
            break;
        default:
            break;
    }
    return result;
};
exports.getCssPadding = getCssPadding;
// 默认箭头样式
var getArrowCfg = function (arrowCfg, edge) {
    if (!arrowCfg) {
        return;
    }
    if (typeof arrowCfg === 'function') {
        return arrowCfg(edge);
    }
    if ((arrowCfg === null || arrowCfg === void 0 ? void 0 : arrowCfg.show) === false) {
        return;
    }
    var _a = arrowCfg.type, type = _a === void 0 ? 'vee' : _a, _b = arrowCfg.d, d = _b === void 0 ? 0 : _b, _c = arrowCfg.size, size = _c === void 0 ? 10 : _c;
    return __assign({ path: g6_1.default.Arrow[type](size, size, d), fill: '#ccc', d: d }, arrowCfg);
};
exports.getArrowCfg = getArrowCfg;
// 交互
var bindStateEvents = function (graph, cfg) {
    var _a = cfg !== null && cfg !== void 0 ? cfg : {}, _b = _a.nodeCfg, nodeCfg = _b === void 0 ? {} : _b, _c = _a.edgeCfg, edgeCfg = _c === void 0 ? {} : _c;
    var nodeStateStyles = nodeCfg.nodeStateStyles;
    var edgeStateStyles = edgeCfg.edgeStateStyles;
    /**
     * 存储交互状态
     * id: [[endActive, endDefalut], [startActive, startDefalut]]
     */
    var statusCache = {};
    var updateArrowFill = function (item, endArrowFill, stratArrowFill) {
        graph.updateItem(item, {
            style: {
                endArrow: !!endArrowFill && {
                    fill: endArrowFill,
                },
                startArrow: !!stratArrowFill && {
                    fill: stratArrowFill,
                },
            },
        });
    };
    var setState = function (item, name, status) {
        var _a, _b, _c;
        status ? item.toFront() : item.toBack();
        var _d = (_a = item.getModel().style) !== null && _a !== void 0 ? _a : {}, endArrow = _d.endArrow, startArrow = _d.startArrow;
        if (endArrow || startArrow) {
            if (!statusCache[item.getID()]) {
                //@ts-ignore
                var endArrowFill = (endArrow !== null && endArrow !== void 0 ? endArrow : {}).fill;
                //@ts-ignore
                var startArrowFill = (startArrow !== null && startArrow !== void 0 ? startArrow : {}).fill;
                var hoverStatus = (_c = (_b = item.getModel().style) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.stroke;
                statusCache[item.getID()] = [
                    [hoverStatus !== null && hoverStatus !== void 0 ? hoverStatus : endArrowFill, endArrowFill],
                    [hoverStatus !== null && hoverStatus !== void 0 ? hoverStatus : startArrowFill, startArrowFill],
                ];
            }
            var fill = statusCache[item.getID()];
            updateArrowFill(item, endArrow && fill[0][status ? 0 : 1], startArrow && fill[1][status ? 0 : 1]);
        }
        graph.setItemState(item, name, status);
    };
    var getRelationItems = function (currentItem, name, status, type) {
        var relationItems = type === 'node'
            ? graph.findAll('edge', function (edge) { return edge.getSource() === currentItem || edge.getTarget() === currentItem; })
            : graph.findAll('node', function (node) {
                return currentItem.getSource().get('id') === node.get('id') ||
                    currentItem.getTarget().get('id') === node.get('id');
            });
        var highlightItems = [currentItem].concat(relationItems);
        highlightItems.forEach(function (item) {
            setState(item, name, status);
        });
    };
    if (nodeStateStyles) {
        graph.on('node:mouseenter', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', true, 'node');
        });
        graph.on('node:mouseleave', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', false, 'node');
        });
    }
    if (edgeStateStyles) {
        graph.on('edge:mouseenter', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', true, 'edge');
        });
        graph.on('edge:mouseleave', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', false, 'edge');
        });
    }
};
exports.bindStateEvents = bindStateEvents;
// 统一处理 config，支持回调
var getStyle = function (source, cfg, item, current) {
    if (typeof source === 'function') {
        return source(cfg, item, current);
    }
    return source || {};
};
exports.getStyle = getStyle;
// 统一处理 config，支持回调
var getCommonConfig = function (cfg, item, graph) {
    if (typeof cfg === 'function') {
        return cfg(item, graph);
    }
    return cfg;
};
exports.getCommonConfig = getCommonConfig;
