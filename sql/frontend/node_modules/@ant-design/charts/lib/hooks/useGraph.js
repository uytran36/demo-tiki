"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var utils_1 = require("../graphs/utils");
var util_1 = require("@antv/util");
function useInit(graphInstance, config, container) {
    var graphHook = react_1.useRef();
    var data = config.data, nodeStyle = config.nodeStyle, nodeAnchorPoints = config.nodeAnchorPoints, nodeType = config.nodeType, edgeType = config.edgeType, edgeStyle = config.edgeStyle, width = config.width, height = config.height, layout = config.layout, minimapCfg = config.minimapCfg, behaviors = config.behaviors, nodeLabelCfg = config.nodeLabelCfg, edgeLabelCfg = config.edgeLabelCfg, _a = config.autoFit, autoFit = _a === void 0 ? true : _a, _b = config.adjustLayout, adjustLayout = _b === void 0 ? true : _b;
    var minimap;
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.changeData(data);
            if (adjustLayout) {
                autoFit ? graphInstance.fitView() : graphInstance.fitCenter();
            }
        }
    }, [data]);
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.getNodes().forEach(function (node) {
                graphInstance.updateItem(node, {
                    type: nodeType,
                    style: nodeStyle,
                    anchorPoints: nodeAnchorPoints,
                    labelCfg: nodeLabelCfg,
                });
            });
        }
    }, [nodeStyle, nodeAnchorPoints, nodeType]);
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.getEdges().forEach(function (edge) {
                graphInstance.updateItem(edge, {
                    type: edgeType,
                    style: edgeStyle,
                    labelCfg: edgeLabelCfg,
                });
            });
        }
    }, [edgeStyle, edgeType]);
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            var graphSize = utils_1.getGraphSize(width, height, container);
            graphInstance.changeSize(graphSize[0], graphSize[1]);
        }
    }, [container, width, height]);
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            graphInstance.updateLayout(layout);
        }
    }, [layout]);
    react_1.useEffect(function () {
        if (!minimapCfg || !graphInstance || graphInstance.destroyed) {
            return;
        }
        if (minimapCfg.show) {
            minimap = utils_1.processMinimap(minimapCfg, graphInstance);
            minimap === null || minimap === void 0 ? void 0 : minimap.updateCanvas();
        }
        else {
            var pluginMinimap = graphInstance.get('plugins')[0];
            if (pluginMinimap) {
                graphInstance.removePlugin(pluginMinimap);
            }
        }
    }, [minimapCfg]);
    react_1.useEffect(function () {
        if (graphInstance && !graphInstance.destroyed) {
            var defaultMode = graphInstance.get('modes').default;
            var removingBehaviors_1 = [];
            defaultMode.forEach(function (be) {
                if (util_1.isObject(be)) {
                    removingBehaviors_1.push(be.type);
                }
                else if (util_1.isString(be)) {
                    removingBehaviors_1.push(be);
                }
            });
            graphInstance.removeBehaviors(removingBehaviors_1, 'default');
            graphInstance.addBehaviors(behaviors, 'default');
        }
    }, [behaviors]);
    react_1.useEffect(function () {
        graphHook.current = graphInstance;
        return function () {
            if (graphInstance && !graphInstance.destroyed) {
                graphInstance.destroy();
                graphInstance = undefined;
            }
        };
    }, []);
    return {
        graphHook: graphHook,
    };
}
exports.default = useInit;
