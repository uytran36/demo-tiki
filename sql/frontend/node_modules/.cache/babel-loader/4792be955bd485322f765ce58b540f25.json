{"ast":null,"code":"/**\r\n * @description 扩展方法，提供 gl-matrix 为提供的方法\r\n * */\nimport { mat3, vec2 } from 'gl-matrix';\nexport function leftTranslate(out, a, v) {\n  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  mat3.fromTranslation(transMat, v);\n  return mat3.multiply(out, transMat, a);\n}\nexport function leftRotate(out, a, rad) {\n  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  mat3.fromRotation(rotateMat, rad);\n  return mat3.multiply(out, rotateMat, a);\n}\nexport function leftScale(out, a, v) {\n  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  mat3.fromScaling(scaleMat, v);\n  return mat3.multiply(out, scaleMat, a);\n}\n\nfunction leftMultiply(out, a, a1) {\n  return mat3.multiply(out, a1, a);\n}\n/**\r\n * 根据 actions 来做 transform\r\n * @param m\r\n * @param actions\r\n */\n\n\nexport function transform(m, actions) {\n  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0, len = actions.length; i < len; i++) {\n    var action = actions[i];\n\n    switch (action[0]) {\n      case 't':\n        leftTranslate(matrix, matrix, [action[1], action[2]]);\n        break;\n\n      case 's':\n        leftScale(matrix, matrix, [action[1], action[2]]);\n        break;\n\n      case 'r':\n        leftRotate(matrix, matrix, action[1]);\n        break;\n\n      case 'm':\n        leftMultiply(matrix, matrix, action[1]);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return matrix;\n}\n/**\r\n * 向量 v1 到 向量 v2 夹角的方向\r\n * @param  {Array} v1 向量\r\n * @param  {Array} v2 向量\r\n * @return {Boolean} >= 0 顺时针 < 0 逆时针\r\n */\n\nexport function direction(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n/**\r\n * 二维向量 v1 到 v2 的夹角\r\n * @param v1\r\n * @param v2\r\n * @param direct\r\n */\n\nexport function angleTo(v1, v2, direct) {\n  var ang = vec2.angle(v1, v2);\n  var angleLargeThanPI = direction(v1, v2) >= 0;\n\n  if (direct) {\n    if (angleLargeThanPI) {\n      return Math.PI * 2 - ang;\n    }\n\n    return ang;\n  }\n\n  if (angleLargeThanPI) {\n    return ang;\n  }\n\n  return Math.PI * 2 - ang;\n}\n/**\r\n * 计算二维向量的垂直向量\r\n * @param out\r\n * @param v\r\n * @param flag\r\n */\n\nexport function vertical(out, v, flag) {\n  if (flag) {\n    out[0] = v[1];\n    out[1] = -1 * v[0];\n  } else {\n    out[0] = -1 * v[1];\n    out[1] = v[0];\n  }\n\n  return out;\n}","map":{"version":3,"sources":["../src/ext.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @description 扩展方法，提供 gl-matrix 为提供的方法\r\n * */\r\nimport { mat3, vec2 } from 'gl-matrix';\r\nexport function leftTranslate(out, a, v) {\r\n    var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    mat3.fromTranslation(transMat, v);\r\n    return mat3.multiply(out, transMat, a);\r\n}\r\nexport function leftRotate(out, a, rad) {\r\n    var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    mat3.fromRotation(rotateMat, rad);\r\n    return mat3.multiply(out, rotateMat, a);\r\n}\r\nexport function leftScale(out, a, v) {\r\n    var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    mat3.fromScaling(scaleMat, v);\r\n    return mat3.multiply(out, scaleMat, a);\r\n}\r\nfunction leftMultiply(out, a, a1) {\r\n    return mat3.multiply(out, a1, a);\r\n}\r\n/**\r\n * 根据 actions 来做 transform\r\n * @param m\r\n * @param actions\r\n */\r\nexport function transform(m, actions) {\r\n    var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    for (var i = 0, len = actions.length; i < len; i++) {\r\n        var action = actions[i];\r\n        switch (action[0]) {\r\n            case 't':\r\n                leftTranslate(matrix, matrix, [action[1], action[2]]);\r\n                break;\r\n            case 's':\r\n                leftScale(matrix, matrix, [action[1], action[2]]);\r\n                break;\r\n            case 'r':\r\n                leftRotate(matrix, matrix, action[1]);\r\n                break;\r\n            case 'm':\r\n                leftMultiply(matrix, matrix, action[1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return matrix;\r\n}\r\n/**\r\n * 向量 v1 到 向量 v2 夹角的方向\r\n * @param  {Array} v1 向量\r\n * @param  {Array} v2 向量\r\n * @return {Boolean} >= 0 顺时针 < 0 逆时针\r\n */\r\nexport function direction(v1, v2) {\r\n    return v1[0] * v2[1] - v2[0] * v1[1];\r\n}\r\n/**\r\n * 二维向量 v1 到 v2 的夹角\r\n * @param v1\r\n * @param v2\r\n * @param direct\r\n */\r\nexport function angleTo(v1, v2, direct) {\r\n    var ang = vec2.angle(v1, v2);\r\n    var angleLargeThanPI = direction(v1, v2) >= 0;\r\n    if (direct) {\r\n        if (angleLargeThanPI) {\r\n            return Math.PI * 2 - ang;\r\n        }\r\n        return ang;\r\n    }\r\n    if (angleLargeThanPI) {\r\n        return ang;\r\n    }\r\n    return Math.PI * 2 - ang;\r\n}\r\n/**\r\n * 计算二维向量的垂直向量\r\n * @param out\r\n * @param v\r\n * @param flag\r\n */\r\nexport function vertical(out, v, flag) {\r\n    if (flag) {\r\n        out[0] = v[1];\r\n        out[1] = -1 * v[0];\r\n    }\r\n    else {\r\n        out[0] = -1 * v[1];\r\n        out[1] = v[0];\r\n    }\r\n    return out;\r\n}\r\n//# sourceMappingURL=ext.js.map"]},"metadata":{},"sourceType":"module"}