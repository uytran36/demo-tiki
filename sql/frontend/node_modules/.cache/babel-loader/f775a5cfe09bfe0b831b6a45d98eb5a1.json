{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Cache = _.Cache;\n\nvar Stack =\n/** @class */\nfunction (_super) {\n  __extends(Stack, _super);\n\n  function Stack(cfg) {\n    var _this = _super.call(this, cfg) || this;\n\n    var _a = cfg.adjustNames,\n        adjustNames = _a === void 0 ? ['y'] : _a,\n        _b = cfg.height,\n        height = _b === void 0 ? NaN : _b,\n        _c = cfg.size,\n        size = _c === void 0 ? 10 : _c,\n        _d = cfg.reverseOrder,\n        reverseOrder = _d === void 0 ? false : _d;\n    _this.adjustNames = adjustNames;\n    _this.height = height;\n    _this.size = size;\n    _this.reverseOrder = reverseOrder;\n    return _this;\n  }\n  /**\r\n   * 方法入参是经过数据分组、数据数字化之后的二维数组\r\n   * @param groupDataArray 分组之后的数据\r\n   */\n\n\n  Stack.prototype.process = function (groupDataArray) {\n    var _a = this,\n        yField = _a.yField,\n        reverseOrder = _a.reverseOrder; // 如果有指定 y 字段，那么按照 y 字段来 stack\n    // 否则，按照高度均分\n\n\n    var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);\n    return reverseOrder ? this.reverse(d) : d;\n  };\n\n  Stack.prototype.reverse = function (groupedDataArray) {\n    return groupedDataArray.slice(0).reverse();\n  };\n\n  Stack.prototype.processStack = function (groupDataArray) {\n    var _a = this,\n        xField = _a.xField,\n        yField = _a.yField,\n        reverseOrder = _a.reverseOrder; // 层叠顺序翻转\n\n\n    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray; // 用来缓存，正数和负数的堆叠问题\n\n    var positive = new Cache();\n    var negative = new Cache();\n    return groupedDataArray.map(function (dataArray) {\n      return dataArray.map(function (data) {\n        var _a;\n\n        var x = _.get(data, xField, 0);\n\n        var y = _.get(data, [yField]);\n\n        var xKey = x.toString(); // todo 是否应该取 _origin？因为 y 可能取到的值不正确，比如先 symmetric，再 stack！\n\n        y = _.isArray(y) ? y[1] : y;\n\n        if (!_.isNil(y)) {\n          var cache = y >= 0 ? positive : negative;\n\n          if (!cache.has(xKey)) {\n            cache.set(xKey, 0);\n          }\n\n          var xValue = cache.get(xKey);\n          var newXValue = y + xValue; // 存起来\n\n          cache.set(xKey, newXValue);\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = [xValue, newXValue], _a));\n        } // 没有修改，则直接返回\n\n\n        return data;\n      });\n    });\n  };\n\n  Stack.prototype.processOneDimStack = function (groupDataArray) {\n    var _this = this;\n\n    var _a = this,\n        xField = _a.xField,\n        height = _a.height,\n        reverseOrder = _a.reverseOrder;\n\n    var yField = 'y'; // 如果层叠的顺序翻转\n\n    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray; // 缓存累加数据\n\n    var cache = new Cache();\n    return groupedDataArray.map(function (dataArray) {\n      return dataArray.map(function (data) {\n        var _a;\n\n        var size = _this.size;\n        var xValue = data[xField]; // todo 没有看到这个 stack 计算原理\n\n        var stackHeight = size * 2 / height;\n\n        if (!cache.has(xValue)) {\n          cache.set(xValue, stackHeight / 2); // 初始值大小\n        }\n\n        var stackValue = cache.get(xValue); // 增加一层 stackHeight\n\n        cache.set(xValue, stackValue + stackHeight);\n        return __assign(__assign({}, data), (_a = {}, _a[yField] = stackValue, _a));\n      });\n    });\n  };\n\n  return Stack;\n}(Adjust);\n\nexport default Stack;","map":{"version":3,"sources":["../../src/adjusts/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport * as _ from '@antv/util';\r\nimport Adjust from './adjust';\r\nvar Cache = _.Cache;\r\nvar Stack = /** @class */ (function (_super) {\r\n    __extends(Stack, _super);\r\n    function Stack(cfg) {\r\n        var _this = _super.call(this, cfg) || this;\r\n        var _a = cfg.adjustNames, adjustNames = _a === void 0 ? ['y'] : _a, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;\r\n        _this.adjustNames = adjustNames;\r\n        _this.height = height;\r\n        _this.size = size;\r\n        _this.reverseOrder = reverseOrder;\r\n        return _this;\r\n    }\r\n    /**\r\n     * 方法入参是经过数据分组、数据数字化之后的二维数组\r\n     * @param groupDataArray 分组之后的数据\r\n     */\r\n    Stack.prototype.process = function (groupDataArray) {\r\n        var _a = this, yField = _a.yField, reverseOrder = _a.reverseOrder;\r\n        // 如果有指定 y 字段，那么按照 y 字段来 stack\r\n        // 否则，按照高度均分\r\n        var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);\r\n        return reverseOrder ? this.reverse(d) : d;\r\n    };\r\n    Stack.prototype.reverse = function (groupedDataArray) {\r\n        return groupedDataArray.slice(0).reverse();\r\n    };\r\n    Stack.prototype.processStack = function (groupDataArray) {\r\n        var _a = this, xField = _a.xField, yField = _a.yField, reverseOrder = _a.reverseOrder;\r\n        // 层叠顺序翻转\r\n        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;\r\n        // 用来缓存，正数和负数的堆叠问题\r\n        var positive = new Cache();\r\n        var negative = new Cache();\r\n        return groupedDataArray.map(function (dataArray) {\r\n            return dataArray.map(function (data) {\r\n                var _a;\r\n                var x = _.get(data, xField, 0);\r\n                var y = _.get(data, [yField]);\r\n                var xKey = x.toString();\r\n                // todo 是否应该取 _origin？因为 y 可能取到的值不正确，比如先 symmetric，再 stack！\r\n                y = _.isArray(y) ? y[1] : y;\r\n                if (!_.isNil(y)) {\r\n                    var cache = y >= 0 ? positive : negative;\r\n                    if (!cache.has(xKey)) {\r\n                        cache.set(xKey, 0);\r\n                    }\r\n                    var xValue = cache.get(xKey);\r\n                    var newXValue = y + xValue;\r\n                    // 存起来\r\n                    cache.set(xKey, newXValue);\r\n                    return __assign(__assign({}, data), (_a = {}, _a[yField] = [xValue, newXValue], _a));\r\n                }\r\n                // 没有修改，则直接返回\r\n                return data;\r\n            });\r\n        });\r\n    };\r\n    Stack.prototype.processOneDimStack = function (groupDataArray) {\r\n        var _this = this;\r\n        var _a = this, xField = _a.xField, height = _a.height, reverseOrder = _a.reverseOrder;\r\n        var yField = 'y';\r\n        // 如果层叠的顺序翻转\r\n        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;\r\n        // 缓存累加数据\r\n        var cache = new Cache();\r\n        return groupedDataArray.map(function (dataArray) {\r\n            return dataArray.map(function (data) {\r\n                var _a;\r\n                var size = _this.size;\r\n                var xValue = data[xField];\r\n                // todo 没有看到这个 stack 计算原理\r\n                var stackHeight = (size * 2) / height;\r\n                if (!cache.has(xValue)) {\r\n                    cache.set(xValue, stackHeight / 2); // 初始值大小\r\n                }\r\n                var stackValue = cache.get(xValue);\r\n                // 增加一层 stackHeight\r\n                cache.set(xValue, stackValue + stackHeight);\r\n                return __assign(__assign({}, data), (_a = {}, _a[yField] = stackValue, _a));\r\n            });\r\n        });\r\n    };\r\n    return Stack;\r\n}(Adjust));\r\nexport default Stack;\r\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}