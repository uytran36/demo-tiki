{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = {\n  longestPath: longestPath,\n  slack: slack\n};\n/*\r\n * Initializes ranks for the input graph using the longest path algorithm. This\r\n * algorithm scales well and is fast in practice, it yields rather poor\r\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\r\n * ranks wide and leaving edges longer than necessary. However, due to its\r\n * speed, this algorithm is good for getting an initial ranking that can be fed\r\n * into other algorithms.\r\n *\r\n * This algorithm does not normalize layers because it will be used by other\r\n * algorithms in most cases. If using this algorithm directly, be sure to\r\n * run normalize at the end.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Input graph is a DAG.\r\n *    2. Input graph node labels can be assigned properties.\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\r\n */\n\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n\n    if (_.has(visited, v)) {\n      return label.rank;\n    }\n\n    visited[v] = true;\n\n    var rank = _.min(_.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    }));\n\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n    rank === undefined || // return value of _.map([]) for Lodash 4\n    rank === null) {\n      // return value of _.map([null])\n      rank = 0;\n    }\n\n    return label.rank = rank;\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n/*\r\n * Returns the amount of slack for the given edge. The slack is defined as the\r\n * difference between the length of the edge and its minimum length.\r\n */\n\n\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/dagre/lib/rank/util.js"],"names":["_","require","module","exports","longestPath","slack","g","visited","dfs","v","label","node","has","rank","min","map","outEdges","e","w","edge","minlen","Number","POSITIVE_INFINITY","undefined","forEach","sources"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,WAAD,CAAf;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,WAAW,EAAEA,WADE;AAEfC,EAAAA,KAAK,EAAEA;AAFQ,CAAjB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,WAAT,CAAqBE,CAArB,EAAwB;AACtB,MAAIC,OAAO,GAAG,EAAd;;AAEA,WAASC,GAAT,CAAaC,CAAb,EAAgB;AACd,QAAIC,KAAK,GAAGJ,CAAC,CAACK,IAAF,CAAOF,CAAP,CAAZ;;AACA,QAAIT,CAAC,CAACY,GAAF,CAAML,OAAN,EAAeE,CAAf,CAAJ,EAAuB;AACrB,aAAOC,KAAK,CAACG,IAAb;AACD;;AACDN,IAAAA,OAAO,CAACE,CAAD,CAAP,GAAa,IAAb;;AAEA,QAAII,IAAI,GAAGb,CAAC,CAACc,GAAF,CAAMd,CAAC,CAACe,GAAF,CAAMT,CAAC,CAACU,QAAF,CAAWP,CAAX,CAAN,EAAqB,UAASQ,CAAT,EAAY;AAChD,aAAOT,GAAG,CAACS,CAAC,CAACC,CAAH,CAAH,GAAWZ,CAAC,CAACa,IAAF,CAAOF,CAAP,EAAUG,MAA5B;AACD,KAFgB,CAAN,CAAX;;AAIA,QAAIP,IAAI,KAAKQ,MAAM,CAACC,iBAAhB,IAAqC;AACrCT,IAAAA,IAAI,KAAKU,SADT,IACsB;AACtBV,IAAAA,IAAI,KAAK,IAFb,EAEmB;AAAE;AACnBA,MAAAA,IAAI,GAAG,CAAP;AACD;;AAED,WAAQH,KAAK,CAACG,IAAN,GAAaA,IAArB;AACD;;AAEDb,EAAAA,CAAC,CAACwB,OAAF,CAAUlB,CAAC,CAACmB,OAAF,EAAV,EAAuBjB,GAAvB;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASH,KAAT,CAAeC,CAAf,EAAkBW,CAAlB,EAAqB;AACnB,SAAOX,CAAC,CAACK,IAAF,CAAOM,CAAC,CAACC,CAAT,EAAYL,IAAZ,GAAmBP,CAAC,CAACK,IAAF,CAAOM,CAAC,CAACR,CAAT,EAAYI,IAA/B,GAAsCP,CAAC,CAACa,IAAF,CAAOF,CAAP,EAAUG,MAAvD;AACD","sourcesContent":["\"use strict\";\r\n\r\nvar _ = require(\"../lodash\");\r\n\r\nmodule.exports = {\r\n  longestPath: longestPath,\r\n  slack: slack\r\n};\r\n\r\n/*\r\n * Initializes ranks for the input graph using the longest path algorithm. This\r\n * algorithm scales well and is fast in practice, it yields rather poor\r\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\r\n * ranks wide and leaving edges longer than necessary. However, due to its\r\n * speed, this algorithm is good for getting an initial ranking that can be fed\r\n * into other algorithms.\r\n *\r\n * This algorithm does not normalize layers because it will be used by other\r\n * algorithms in most cases. If using this algorithm directly, be sure to\r\n * run normalize at the end.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Input graph is a DAG.\r\n *    2. Input graph node labels can be assigned properties.\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\r\n */\r\nfunction longestPath(g) {\r\n  var visited = {};\r\n\r\n  function dfs(v) {\r\n    var label = g.node(v);\r\n    if (_.has(visited, v)) {\r\n      return label.rank;\r\n    }\r\n    visited[v] = true;\r\n\r\n    var rank = _.min(_.map(g.outEdges(v), function(e) {\r\n      return dfs(e.w) - g.edge(e).minlen;\r\n    }));\r\n\r\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\r\n        rank === undefined || // return value of _.map([]) for Lodash 4\r\n        rank === null) { // return value of _.map([null])\r\n      rank = 0;\r\n    }\r\n\r\n    return (label.rank = rank);\r\n  }\r\n\r\n  _.forEach(g.sources(), dfs);\r\n}\r\n\r\n/*\r\n * Returns the amount of slack for the given edge. The slack is defined as the\r\n * difference between the length of the edge and its minimum length.\r\n */\r\nfunction slack(g, e) {\r\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}