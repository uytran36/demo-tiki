{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nvar initOrder = require(\"./init-order\");\n\nvar crossCount = require(\"./cross-count\");\n\nvar sortSubgraph = require(\"./sort-subgraph\");\n\nvar buildLayerGraph = require(\"./build-layer-graph\");\n\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\n\nvar Graph = require(\"../graphlib\").Graph;\n\nvar util = require(\"../util\");\n\nmodule.exports = order;\n/*\r\n * Applies heuristics to minimize edge crossings in the graph and sets the best\r\n * order solution as an order attribute on each node.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Graph must be DAG\r\n *    2. Graph nodes must be objects with a \"rank\" attribute\r\n *    3. Graph edges must have the \"weight\" attribute\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\r\n *       algorithm.\r\n */\n\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n      downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n      upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n  var bestCC = Number.POSITIVE_INFINITY,\n      best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/dagre/lib/order/index.js"],"names":["_","require","initOrder","crossCount","sortSubgraph","buildLayerGraph","addSubgraphConstraints","Graph","util","module","exports","order","g","maxRank","downLayerGraphs","buildLayerGraphs","range","upLayerGraphs","layering","assignOrder","bestCC","Number","POSITIVE_INFINITY","best","i","lastBest","sweepLayerGraphs","buildLayerMatrix","cc","cloneDeep","ranks","relationship","map","rank","layerGraphs","biasRight","cg","forEach","lg","root","graph","sorted","vs","v","node","layer"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _ = require(\"../lodash\");\r\nvar initOrder = require(\"./init-order\");\r\nvar crossCount = require(\"./cross-count\");\r\nvar sortSubgraph = require(\"./sort-subgraph\");\r\nvar buildLayerGraph = require(\"./build-layer-graph\");\r\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\r\nvar Graph = require(\"../graphlib\").Graph;\r\nvar util = require(\"../util\");\r\n\r\nmodule.exports = order;\r\n\r\n/*\r\n * Applies heuristics to minimize edge crossings in the graph and sets the best\r\n * order solution as an order attribute on each node.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Graph must be DAG\r\n *    2. Graph nodes must be objects with a \"rank\" attribute\r\n *    3. Graph edges must have the \"weight\" attribute\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\r\n *       algorithm.\r\n */\r\nfunction order(g) {\r\n  var maxRank = util.maxRank(g),\r\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\r\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\r\n\r\n  var layering = initOrder(g);\r\n  assignOrder(g, layering);\r\n\r\n  var bestCC = Number.POSITIVE_INFINITY,\r\n    best;\r\n\r\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\r\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\r\n\r\n    layering = util.buildLayerMatrix(g);\r\n    var cc = crossCount(g, layering);\r\n    if (cc < bestCC) {\r\n      lastBest = 0;\r\n      best = _.cloneDeep(layering);\r\n      bestCC = cc;\r\n    }\r\n  }\r\n\r\n  assignOrder(g, best);\r\n}\r\n\r\nfunction buildLayerGraphs(g, ranks, relationship) {\r\n  return _.map(ranks, function(rank) {\r\n    return buildLayerGraph(g, rank, relationship);\r\n  });\r\n}\r\n\r\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\r\n  var cg = new Graph();\r\n  _.forEach(layerGraphs, function(lg) {\r\n    var root = lg.graph().root;\r\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\r\n    _.forEach(sorted.vs, function(v, i) {\r\n      lg.node(v).order = i;\r\n    });\r\n    addSubgraphConstraints(lg, cg, sorted.vs);\r\n  });\r\n}\r\n\r\nfunction assignOrder(g, layering) {\r\n  _.forEach(layering, function(layer) {\r\n    _.forEach(layer, function(v, i) {\r\n      g.node(v).order = i;\r\n    });\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}