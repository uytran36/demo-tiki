{"ast":null,"code":"/**\r\n * @fileOverview random layout\r\n * @author shiwu.wyy@antfin.com\r\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\r\n * 经典力导布局 force-directed\r\n */\n\nexport class ForceLayout extends Base {\n  constructor(options) {\n    super();\n    /** 向心力作用点 */\n\n    this.center = [0, 0];\n    /** 节点作用力 */\n\n    this.nodeStrength = null;\n    /** 边的作用力, 默认为根据节点的入度出度自适应 */\n\n    this.edgeStrength = null;\n    /** 是否防止节点相互覆盖 */\n\n    this.preventOverlap = false;\n    /** 聚类节点作用力 */\n\n    this.clusterNodeStrength = null;\n    /** 聚类边作用力 */\n\n    this.clusterEdgeStrength = null;\n    /** 聚类边长度 */\n\n    this.clusterEdgeDistance = null;\n    /** 聚类节点大小 / 直径，直径越大，越分散 */\n\n    this.clusterNodeSize = null;\n    /** 用于 foci 的力 */\n\n    this.clusterFociStrength = null;\n    /** 默认边长度 */\n\n    this.linkDistance = 50;\n    /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n\n    this.alphaDecay = 0.028;\n    /** 停止迭代的阈值 */\n\n    this.alphaMin = 0.001;\n    /** 当前阈值 */\n\n    this.alpha = 0.3;\n    /** 防止重叠的力强度 */\n\n    this.collideStrength = 1;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n\n    this.tick = () => {};\n    /** 布局完成回调 */\n\n\n    this.onLayoutEnd = () => {};\n    /** 是否正在布局 */\n\n\n    this.ticking = undefined;\n\n    if (options) {\n      this.updateCfg(options);\n    }\n  }\n\n  getDefaultCfg() {\n    return {\n      center: [0, 0],\n      nodeStrength: null,\n      edgeStrength: null,\n      preventOverlap: false,\n      nodeSize: undefined,\n      nodeSpacing: undefined,\n      linkDistance: 50,\n      forceSimulation: null,\n      alphaDecay: 0.028,\n      alphaMin: 0.001,\n      alpha: 0.3,\n      collideStrength: 1,\n      clustering: false,\n      clusterNodeStrength: -1,\n      clusterEdgeStrength: 0.1,\n      clusterEdgeDistance: 100,\n      clusterFociStrength: 0.8,\n      clusterNodeSize: 10,\n\n      tick() {},\n\n      onLayoutEnd() {},\n\n      // 是否启用web worker。前提是在web worker里执行布局，否则无效\n      workerEnabled: false\n    };\n  }\n  /**\r\n   * 初始化\r\n   * @param {object} data 数据\r\n   */\n\n\n  init(data) {\n    const self = this;\n    self.nodes = data.nodes || [];\n    const edges = data.edges || [];\n    self.edges = edges.map(edge => {\n      const res = {};\n      const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n      Object.keys(edge).forEach(key => {\n        if (!(expectKeys.indexOf(key) > -1)) {\n          res[key] = edge[key];\n        }\n      });\n      return res;\n    });\n    self.ticking = false;\n  }\n  /**\r\n   * 执行布局\r\n   */\n\n\n  execute(reloadData) {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges; // 如果正在布局，忽略布局请求\n\n    if (self.ticking) {\n      return;\n    }\n\n    let simulation = self.forceSimulation;\n    const alphaMin = self.alphaMin;\n    const alphaDecay = self.alphaDecay;\n    const alpha = self.alpha;\n\n    if (!simulation) {\n      try {\n        // 定义节点的力\n        const nodeForce = d3Force.forceManyBody();\n\n        if (self.nodeStrength) {\n          nodeForce.strength(self.nodeStrength);\n        }\n\n        simulation = d3Force.forceSimulation().nodes(nodes);\n\n        if (self.clustering) {\n          const clusterForce = forceInABox();\n          clusterForce.centerX(self.center[0]).centerY(self.center[1]).template(\"force\").strength(self.clusterFociStrength);\n\n          if (edges) {\n            clusterForce.links(edges);\n          }\n\n          if (nodes) {\n            clusterForce.nodes(nodes);\n          }\n\n          clusterForce.forceLinkDistance(self.clusterEdgeDistance).forceLinkStrength(self.clusterEdgeStrength).forceCharge(self.clusterNodeStrength).forceNodeSize(self.clusterNodeSize);\n          self.clusterForce = clusterForce;\n          simulation.force(\"group\", clusterForce);\n        }\n\n        simulation.force(\"center\", d3Force.forceCenter(self.center[0], self.center[1])).force(\"charge\", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);\n\n        if (self.preventOverlap) {\n          self.overlapProcess(simulation);\n        } // 如果有边，定义边的力\n\n\n        if (edges) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n\n        if (self.workerEnabled && !isInWorker()) {\n          // 如果不是运行在web worker里，不用web worker布局\n          self.workerEnabled = false;\n          console.warn(\"workerEnabled option is only supported when running in web worker.\");\n        }\n\n        if (!self.workerEnabled) {\n          simulation.on(\"tick\", () => {\n            self.tick();\n          }).on(\"end\", () => {\n            self.ticking = false;\n            if (self.onLayoutEnd) self.onLayoutEnd();\n          });\n          self.ticking = true;\n        } else {\n          // worker is enabled\n          simulation.stop();\n          const totalTicks = getSimulationTicks(simulation);\n\n          for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\n            simulation.tick(); // currentTick starts from 1.\n\n            postMessage({\n              nodes,\n              currentTick,\n              totalTicks,\n              type: LAYOUT_MESSAGE.TICK\n            }, undefined);\n          }\n\n          self.ticking = false;\n        }\n\n        self.forceSimulation = simulation;\n        self.ticking = true;\n      } catch (e) {\n        self.ticking = false;\n        console.warn(e);\n      }\n    } else {\n      if (reloadData) {\n        if (self.clustering && self.clusterForce) {\n          self.clusterForce.nodes(nodes);\n          self.clusterForce.links(edges);\n        }\n\n        simulation.nodes(nodes);\n        if (edges && self.edgeForce) self.edgeForce.links(edges);else if (edges && !self.edgeForce) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n      }\n\n      if (self.preventOverlap) {\n        self.overlapProcess(simulation);\n      }\n\n      simulation.alpha(alpha).restart();\n      this.ticking = true;\n    }\n  }\n  /**\r\n   * 防止重叠\r\n   * @param {object} simulation 力模拟模型\r\n   */\n\n\n  overlapProcess(simulation) {\n    const self = this;\n    const nodeSize = self.nodeSize;\n    const nodeSpacing = self.nodeSpacing;\n    let nodeSizeFunc;\n    let nodeSpacingFunc;\n    const collideStrength = self.collideStrength;\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = () => nodeSpacing;\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = () => 0;\n    }\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          return d.size / 2 + nodeSpacingFunc(d);\n        }\n\n        return 10 + nodeSpacingFunc(d);\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = d => {\n        const size = nodeSize(d);\n        return size + nodeSpacingFunc(d);\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else if (isNumber(nodeSize)) {\n      const radius = nodeSize / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else {\n      nodeSizeFunc = () => 10;\n    } // forceCollide's parameter is a radius\n\n\n    simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n  }\n  /**\r\n   * 更新布局配置，但不执行布局\r\n   * @param {object} cfg 需要更新的配置项\r\n   */\n\n\n  updateCfg(cfg) {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.forceSimulation = null;\n    Object.assign(self, cfg);\n  }\n\n  destroy() {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n} // Return total ticks of d3-force simulation\n\nfunction getSimulationTicks(simulation) {\n  const alphaMin = simulation.alphaMin();\n  const alphaTarget = simulation.alphaTarget();\n  const alpha = simulation.alpha();\n  const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());\n  const totalTicks = Math.ceil(totalTicksFloat);\n  return totalTicks;\n} // 判断是否运行在web worker里\n\n\nfunction isInWorker() {\n  // eslint-disable-next-line no-undef\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}","map":{"version":3,"sources":["../../../src/layout/force/force.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @fileOverview random layout\r\n * @author shiwu.wyy@antfin.com\r\n */\r\nimport * as d3Force from \"d3-force\";\r\nimport forceInABox from \"./force-in-a-box\";\r\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\r\nimport { Base } from \"../base\";\r\nimport { LAYOUT_MESSAGE } from \"../constants\";\r\n/**\r\n * 经典力导布局 force-directed\r\n */\r\nexport class ForceLayout extends Base {\r\n    constructor(options) {\r\n        super();\r\n        /** 向心力作用点 */\r\n        this.center = [0, 0];\r\n        /** 节点作用力 */\r\n        this.nodeStrength = null;\r\n        /** 边的作用力, 默认为根据节点的入度出度自适应 */\r\n        this.edgeStrength = null;\r\n        /** 是否防止节点相互覆盖 */\r\n        this.preventOverlap = false;\r\n        /** 聚类节点作用力 */\r\n        this.clusterNodeStrength = null;\r\n        /** 聚类边作用力 */\r\n        this.clusterEdgeStrength = null;\r\n        /** 聚类边长度 */\r\n        this.clusterEdgeDistance = null;\r\n        /** 聚类节点大小 / 直径，直径越大，越分散 */\r\n        this.clusterNodeSize = null;\r\n        /** 用于 foci 的力 */\r\n        this.clusterFociStrength = null;\r\n        /** 默认边长度 */\r\n        this.linkDistance = 50;\r\n        /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\r\n        this.alphaDecay = 0.028;\r\n        /** 停止迭代的阈值 */\r\n        this.alphaMin = 0.001;\r\n        /** 当前阈值 */\r\n        this.alpha = 0.3;\r\n        /** 防止重叠的力强度 */\r\n        this.collideStrength = 1;\r\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\r\n        this.workerEnabled = false;\r\n        this.tick = () => { };\r\n        /** 布局完成回调 */\r\n        this.onLayoutEnd = () => { };\r\n        /** 是否正在布局 */\r\n        this.ticking = undefined;\r\n        if (options) {\r\n            this.updateCfg(options);\r\n        }\r\n    }\r\n    getDefaultCfg() {\r\n        return {\r\n            center: [0, 0],\r\n            nodeStrength: null,\r\n            edgeStrength: null,\r\n            preventOverlap: false,\r\n            nodeSize: undefined,\r\n            nodeSpacing: undefined,\r\n            linkDistance: 50,\r\n            forceSimulation: null,\r\n            alphaDecay: 0.028,\r\n            alphaMin: 0.001,\r\n            alpha: 0.3,\r\n            collideStrength: 1,\r\n            clustering: false,\r\n            clusterNodeStrength: -1,\r\n            clusterEdgeStrength: 0.1,\r\n            clusterEdgeDistance: 100,\r\n            clusterFociStrength: 0.8,\r\n            clusterNodeSize: 10,\r\n            tick() { },\r\n            onLayoutEnd() { },\r\n            // 是否启用web worker。前提是在web worker里执行布局，否则无效\r\n            workerEnabled: false\r\n        };\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @param {object} data 数据\r\n     */\r\n    init(data) {\r\n        const self = this;\r\n        self.nodes = data.nodes || [];\r\n        const edges = data.edges || [];\r\n        self.edges = edges.map((edge) => {\r\n            const res = {};\r\n            const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\r\n            Object.keys(edge).forEach((key) => {\r\n                if (!(expectKeys.indexOf(key) > -1)) {\r\n                    res[key] = edge[key];\r\n                }\r\n            });\r\n            return res;\r\n        });\r\n        self.ticking = false;\r\n    }\r\n    /**\r\n     * 执行布局\r\n     */\r\n    execute(reloadData) {\r\n        const self = this;\r\n        const nodes = self.nodes;\r\n        const edges = self.edges;\r\n        // 如果正在布局，忽略布局请求\r\n        if (self.ticking) {\r\n            return;\r\n        }\r\n        let simulation = self.forceSimulation;\r\n        const alphaMin = self.alphaMin;\r\n        const alphaDecay = self.alphaDecay;\r\n        const alpha = self.alpha;\r\n        if (!simulation) {\r\n            try {\r\n                // 定义节点的力\r\n                const nodeForce = d3Force.forceManyBody();\r\n                if (self.nodeStrength) {\r\n                    nodeForce.strength(self.nodeStrength);\r\n                }\r\n                simulation = d3Force.forceSimulation().nodes(nodes);\r\n                if (self.clustering) {\r\n                    const clusterForce = forceInABox();\r\n                    clusterForce\r\n                        .centerX(self.center[0])\r\n                        .centerY(self.center[1])\r\n                        .template(\"force\")\r\n                        .strength(self.clusterFociStrength);\r\n                    if (edges) {\r\n                        clusterForce.links(edges);\r\n                    }\r\n                    if (nodes) {\r\n                        clusterForce.nodes(nodes);\r\n                    }\r\n                    clusterForce\r\n                        .forceLinkDistance(self.clusterEdgeDistance)\r\n                        .forceLinkStrength(self.clusterEdgeStrength)\r\n                        .forceCharge(self.clusterNodeStrength)\r\n                        .forceNodeSize(self.clusterNodeSize);\r\n                    self.clusterForce = clusterForce;\r\n                    simulation.force(\"group\", clusterForce);\r\n                }\r\n                simulation\r\n                    .force(\"center\", d3Force.forceCenter(self.center[0], self.center[1]))\r\n                    .force(\"charge\", nodeForce)\r\n                    .alpha(alpha)\r\n                    .alphaDecay(alphaDecay)\r\n                    .alphaMin(alphaMin);\r\n                if (self.preventOverlap) {\r\n                    self.overlapProcess(simulation);\r\n                }\r\n                // 如果有边，定义边的力\r\n                if (edges) {\r\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\r\n                    const edgeForce = d3Force\r\n                        .forceLink()\r\n                        .id((d) => d.id)\r\n                        .links(edges);\r\n                    if (self.edgeStrength) {\r\n                        edgeForce.strength(self.edgeStrength);\r\n                    }\r\n                    if (self.linkDistance) {\r\n                        edgeForce.distance(self.linkDistance);\r\n                    }\r\n                    self.edgeForce = edgeForce;\r\n                    simulation.force(\"link\", edgeForce);\r\n                }\r\n                if (self.workerEnabled && !isInWorker()) {\r\n                    // 如果不是运行在web worker里，不用web worker布局\r\n                    self.workerEnabled = false;\r\n                    console.warn(\"workerEnabled option is only supported when running in web worker.\");\r\n                }\r\n                if (!self.workerEnabled) {\r\n                    simulation\r\n                        .on(\"tick\", () => {\r\n                        self.tick();\r\n                    })\r\n                        .on(\"end\", () => {\r\n                        self.ticking = false;\r\n                        if (self.onLayoutEnd)\r\n                            self.onLayoutEnd();\r\n                    });\r\n                    self.ticking = true;\r\n                }\r\n                else {\r\n                    // worker is enabled\r\n                    simulation.stop();\r\n                    const totalTicks = getSimulationTicks(simulation);\r\n                    for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\r\n                        simulation.tick();\r\n                        // currentTick starts from 1.\r\n                        postMessage({\r\n                            nodes,\r\n                            currentTick,\r\n                            totalTicks,\r\n                            type: LAYOUT_MESSAGE.TICK\r\n                        }, undefined);\r\n                    }\r\n                    self.ticking = false;\r\n                }\r\n                self.forceSimulation = simulation;\r\n                self.ticking = true;\r\n            }\r\n            catch (e) {\r\n                self.ticking = false;\r\n                console.warn(e);\r\n            }\r\n        }\r\n        else {\r\n            if (reloadData) {\r\n                if (self.clustering && self.clusterForce) {\r\n                    self.clusterForce.nodes(nodes);\r\n                    self.clusterForce.links(edges);\r\n                }\r\n                simulation.nodes(nodes);\r\n                if (edges && self.edgeForce)\r\n                    self.edgeForce.links(edges);\r\n                else if (edges && !self.edgeForce) {\r\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\r\n                    const edgeForce = d3Force\r\n                        .forceLink()\r\n                        .id((d) => d.id)\r\n                        .links(edges);\r\n                    if (self.edgeStrength) {\r\n                        edgeForce.strength(self.edgeStrength);\r\n                    }\r\n                    if (self.linkDistance) {\r\n                        edgeForce.distance(self.linkDistance);\r\n                    }\r\n                    self.edgeForce = edgeForce;\r\n                    simulation.force(\"link\", edgeForce);\r\n                }\r\n            }\r\n            if (self.preventOverlap) {\r\n                self.overlapProcess(simulation);\r\n            }\r\n            simulation.alpha(alpha).restart();\r\n            this.ticking = true;\r\n        }\r\n    }\r\n    /**\r\n     * 防止重叠\r\n     * @param {object} simulation 力模拟模型\r\n     */\r\n    overlapProcess(simulation) {\r\n        const self = this;\r\n        const nodeSize = self.nodeSize;\r\n        const nodeSpacing = self.nodeSpacing;\r\n        let nodeSizeFunc;\r\n        let nodeSpacingFunc;\r\n        const collideStrength = self.collideStrength;\r\n        if (isNumber(nodeSpacing)) {\r\n            nodeSpacingFunc = () => nodeSpacing;\r\n        }\r\n        else if (isFunction(nodeSpacing)) {\r\n            nodeSpacingFunc = nodeSpacing;\r\n        }\r\n        else {\r\n            nodeSpacingFunc = () => 0;\r\n        }\r\n        if (!nodeSize) {\r\n            nodeSizeFunc = (d) => {\r\n                if (d.size) {\r\n                    if (isArray(d.size)) {\r\n                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\r\n                        return res / 2 + nodeSpacingFunc(d);\r\n                    }\r\n                    if (isObject(d.size)) {\r\n                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;\r\n                        return res / 2 + nodeSpacingFunc(d);\r\n                    }\r\n                    return d.size / 2 + nodeSpacingFunc(d);\r\n                }\r\n                return 10 + nodeSpacingFunc(d);\r\n            };\r\n        }\r\n        else if (isFunction(nodeSize)) {\r\n            nodeSizeFunc = (d) => {\r\n                const size = nodeSize(d);\r\n                return size + nodeSpacingFunc(d);\r\n            };\r\n        }\r\n        else if (isArray(nodeSize)) {\r\n            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\r\n            const radius = larger / 2;\r\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\r\n        }\r\n        else if (isNumber(nodeSize)) {\r\n            const radius = nodeSize / 2;\r\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\r\n        }\r\n        else {\r\n            nodeSizeFunc = () => 10;\r\n        }\r\n        // forceCollide's parameter is a radius\r\n        simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\r\n    }\r\n    /**\r\n     * 更新布局配置，但不执行布局\r\n     * @param {object} cfg 需要更新的配置项\r\n     */\r\n    updateCfg(cfg) {\r\n        const self = this;\r\n        if (self.ticking) {\r\n            self.forceSimulation.stop();\r\n            self.ticking = false;\r\n        }\r\n        self.forceSimulation = null;\r\n        Object.assign(self, cfg);\r\n    }\r\n    destroy() {\r\n        const self = this;\r\n        if (self.ticking) {\r\n            self.forceSimulation.stop();\r\n            self.ticking = false;\r\n        }\r\n        self.nodes = null;\r\n        self.edges = null;\r\n        self.destroyed = true;\r\n    }\r\n}\r\n// Return total ticks of d3-force simulation\r\nfunction getSimulationTicks(simulation) {\r\n    const alphaMin = simulation.alphaMin();\r\n    const alphaTarget = simulation.alphaTarget();\r\n    const alpha = simulation.alpha();\r\n    const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) /\r\n        Math.log(1 - simulation.alphaDecay());\r\n    const totalTicks = Math.ceil(totalTicksFloat);\r\n    return totalTicks;\r\n}\r\n// 判断是否运行在web worker里\r\nfunction isInWorker() {\r\n    // eslint-disable-next-line no-undef\r\n    return (typeof WorkerGlobalScope !== \"undefined\" &&\r\n        self instanceof WorkerGlobalScope);\r\n}\r\n//# sourceMappingURL=force.js.map"]},"metadata":{},"sourceType":"module"}