{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nvar Graph = require(\"../graphlib\").Graph;\n\nvar util = require(\"../util\");\n/*\r\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\r\n * and Simple Horizontal Coordinate Assignment.\"\r\n */\n\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n/*\r\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\r\n * property. A type-1 conflict is one where a non-inner segment crosses an\r\n * inner segment. An inner segment is an edge with both incident nodes marked\r\n * with the \"dummy\" property.\r\n *\r\n * This algorithm scans layer by layer, starting with the second, for type-1\r\n * conflicts between the current layer and the previous layer. For each layer\r\n * it scans the nodes from left to right until it reaches one that is incident\r\n * on an inner segment. It then scans predecessors to determine if they have\r\n * edges that cross that inner segment. At the end a final scan is done for all\r\n * nodes on the current rank to see if they cross the last visited inner\r\n * segment.\r\n *\r\n * This algorithm (safely) assumes that a dummy node will only be incident on a\r\n * single node in the layers being scanned.\r\n */\n\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var // last visited node in the previous layer that is incident on an inner\n    // segment.\n    k0 = 0,\n        // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    scanPos = 0,\n        prevLayerLength = prevLayer.length,\n        lastNode = _.last(layer);\n\n    _.forEach(layer, function (v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n          k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            var uLabel = g.node(u),\n                uPos = uLabel.order;\n\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i];\n\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          var uNode = g.node(u);\n\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n        nextNorthPos,\n        southPos = 0;\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  return _.has(conflicts[v], w);\n}\n/*\r\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\r\n * attempts to align a node with one of its median neighbors. If the edge\r\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\r\n * If a previous node has already formed a block with a node after the node\r\n * we're trying to form a block with, we also ignore that possibility - our\r\n * blocks would be split in that scenario.\r\n */\n\n\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n      align = {},\n      pos = {}; // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function (layer) {\n    var prevIdx = -1;\n\n    _.forEach(layer, function (v) {\n      var ws = neighborFn(v);\n\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) {\n          return pos[w];\n        });\n        var mp = (ws.length - 1) / 2;\n\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return {\n    root: root,\n    align: align\n  };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n      blockG = buildBlockGraph(g, layering, root, reverseSep),\n      borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  } // First pass, assign smallest coordinates\n\n\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  } // Second pass, assign greatest coordinates\n\n\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function (acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    var node = g.node(elem);\n\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG)); // Assign x coordinates to all nodes\n\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n      graphLabel = g.graph(),\n      sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function (layer) {\n    var u;\n\n    _.forEach(layer, function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n\n      if (u) {\n        var uRoot = root[u],\n            prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n/*\r\n * Returns the alignment that has the smallest width of the given alignments.\r\n */\n\n\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n/*\r\n * Align the coordinates of each of the layout alignments such that\r\n * left-biased alignments have their minimum coordinate at the same point as\r\n * the minimum coordinate of the smallest width alignment and right-biased\r\n * alignments have their maximum coordinate at the same point as the maximum\r\n * coordinate of the smallest width alignment.\r\n */\n\n\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n      alignToMin = _.min(alignToVals),\n      alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function (vert) {\n    _.forEach([\"l\", \"r\"], function (horiz) {\n      var alignment = vert + horiz,\n          xs = xss[alignment],\n          delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) {\n          return x + delta;\n        });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n\n  var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n\n  _.forEach([\"u\", \"d\"], function (vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n\n    _.forEach([\"l\", \"r\"], function (horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function (x) {\n          return -x;\n        });\n      }\n\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n    sum += vLabel.width / 2;\n\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}","map":{"version":3,"sources":["E:/sqlindex2/sql/frontend/node_modules/dagre/lib/position/bk.js"],"names":["_","require","Graph","util","module","exports","positionX","findType1Conflicts","findType2Conflicts","addConflict","hasConflict","verticalAlignment","horizontalCompaction","alignCoordinates","findSmallestWidthAlignment","balance","g","layering","conflicts","visitLayer","prevLayer","layer","k0","scanPos","prevLayerLength","length","lastNode","last","forEach","v","i","w","findOtherInnerSegmentNode","k1","node","order","slice","scanNode","predecessors","u","uLabel","uPos","dummy","reduce","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","range","uNode","north","prevNorthPos","nextNorthPos","southLookahead","find","tmp","conflictsV","has","neighborFn","root","align","pos","prevIdx","ws","sortBy","mp","Math","floor","il","ceil","reverseSep","xs","blockG","buildBlockGraph","borderType","iterate","setXsFunc","nextNodesFunc","stack","nodes","elem","pop","visited","push","concat","pass1","inEdges","acc","e","max","edge","pass2","min","outEdges","Number","POSITIVE_INFINITY","bind","successors","blockGraph","graphLabel","graph","sepFn","sep","nodesep","edgesep","vRoot","setNode","uRoot","prevMax","setEdge","xss","minBy","values","NEGATIVE_INFINITY","forIn","x","halfWidth","width","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","delta","xsVals","mapValues","ul","ignore","toLowerCase","map","buildLayerMatrix","merge","adjustedLayering","reverse","inner","smallestWidth","nodeSep","edgeSep","vLabel","wLabel","sum","labelpos"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _ = require(\"../lodash\");\r\nvar Graph = require(\"../graphlib\").Graph;\r\nvar util = require(\"../util\");\r\n\r\n/*\r\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\r\n * and Simple Horizontal Coordinate Assignment.\"\r\n */\r\n\r\nmodule.exports = {\r\n  positionX: positionX,\r\n  findType1Conflicts: findType1Conflicts,\r\n  findType2Conflicts: findType2Conflicts,\r\n  addConflict: addConflict,\r\n  hasConflict: hasConflict,\r\n  verticalAlignment: verticalAlignment,\r\n  horizontalCompaction: horizontalCompaction,\r\n  alignCoordinates: alignCoordinates,\r\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\r\n  balance: balance\r\n};\r\n\r\n/*\r\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\r\n * property. A type-1 conflict is one where a non-inner segment crosses an\r\n * inner segment. An inner segment is an edge with both incident nodes marked\r\n * with the \"dummy\" property.\r\n *\r\n * This algorithm scans layer by layer, starting with the second, for type-1\r\n * conflicts between the current layer and the previous layer. For each layer\r\n * it scans the nodes from left to right until it reaches one that is incident\r\n * on an inner segment. It then scans predecessors to determine if they have\r\n * edges that cross that inner segment. At the end a final scan is done for all\r\n * nodes on the current rank to see if they cross the last visited inner\r\n * segment.\r\n *\r\n * This algorithm (safely) assumes that a dummy node will only be incident on a\r\n * single node in the layers being scanned.\r\n */\r\nfunction findType1Conflicts(g, layering) {\r\n  var conflicts = {};\r\n\r\n  function visitLayer(prevLayer, layer) {\r\n    var\r\n      // last visited node in the previous layer that is incident on an inner\r\n      // segment.\r\n      k0 = 0,\r\n      // Tracks the last node in this layer scanned for crossings with a type-1\r\n      // segment.\r\n      scanPos = 0,\r\n      prevLayerLength = prevLayer.length,\r\n      lastNode = _.last(layer);\r\n\r\n    _.forEach(layer, function(v, i) {\r\n      var w = findOtherInnerSegmentNode(g, v),\r\n        k1 = w ? g.node(w).order : prevLayerLength;\r\n\r\n      if (w || v === lastNode) {\r\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\r\n          _.forEach(g.predecessors(scanNode), function(u) {\r\n            var uLabel = g.node(u),\r\n              uPos = uLabel.order;\r\n            if ((uPos < k0 || k1 < uPos) &&\r\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\r\n              addConflict(conflicts, u, scanNode);\r\n            }\r\n          });\r\n        });\r\n        scanPos = i + 1;\r\n        k0 = k1;\r\n      }\r\n    });\r\n\r\n    return layer;\r\n  }\r\n\r\n  _.reduce(layering, visitLayer);\r\n  return conflicts;\r\n}\r\n\r\nfunction findType2Conflicts(g, layering) {\r\n  var conflicts = {};\r\n\r\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\r\n    var v;\r\n    _.forEach(_.range(southPos, southEnd), function(i) {\r\n      v = south[i];\r\n      if (g.node(v).dummy) {\r\n        _.forEach(g.predecessors(v), function(u) {\r\n          var uNode = g.node(u);\r\n          if (uNode.dummy &&\r\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\r\n            addConflict(conflicts, u, v);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n  function visitLayer(north, south) {\r\n    var prevNorthPos = -1,\r\n      nextNorthPos,\r\n      southPos = 0;\r\n\r\n    _.forEach(south, function(v, southLookahead) {\r\n      if (g.node(v).dummy === \"border\") {\r\n        var predecessors = g.predecessors(v);\r\n        if (predecessors.length) {\r\n          nextNorthPos = g.node(predecessors[0]).order;\r\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\r\n          southPos = southLookahead;\r\n          prevNorthPos = nextNorthPos;\r\n        }\r\n      }\r\n      scan(south, southPos, south.length, nextNorthPos, north.length);\r\n    });\r\n\r\n    return south;\r\n  }\r\n\r\n  _.reduce(layering, visitLayer);\r\n  return conflicts;\r\n}\r\n\r\nfunction findOtherInnerSegmentNode(g, v) {\r\n  if (g.node(v).dummy) {\r\n    return _.find(g.predecessors(v), function(u) {\r\n      return g.node(u).dummy;\r\n    });\r\n  }\r\n}\r\n\r\nfunction addConflict(conflicts, v, w) {\r\n  if (v > w) {\r\n    var tmp = v;\r\n    v = w;\r\n    w = tmp;\r\n  }\r\n\r\n  var conflictsV = conflicts[v];\r\n  if (!conflictsV) {\r\n    conflicts[v] = conflictsV = {};\r\n  }\r\n  conflictsV[w] = true;\r\n}\r\n\r\nfunction hasConflict(conflicts, v, w) {\r\n  if (v > w) {\r\n    var tmp = v;\r\n    v = w;\r\n    w = tmp;\r\n  }\r\n  return _.has(conflicts[v], w);\r\n}\r\n\r\n/*\r\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\r\n * attempts to align a node with one of its median neighbors. If the edge\r\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\r\n * If a previous node has already formed a block with a node after the node\r\n * we're trying to form a block with, we also ignore that possibility - our\r\n * blocks would be split in that scenario.\r\n */\r\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\r\n  var root = {},\r\n    align = {},\r\n    pos = {};\r\n\r\n  // We cache the position here based on the layering because the graph and\r\n  // layering may be out of sync. The layering matrix is manipulated to\r\n  // generate different extreme alignments.\r\n  _.forEach(layering, function(layer) {\r\n    _.forEach(layer, function(v, order) {\r\n      root[v] = v;\r\n      align[v] = v;\r\n      pos[v] = order;\r\n    });\r\n  });\r\n\r\n  _.forEach(layering, function(layer) {\r\n    var prevIdx = -1;\r\n    _.forEach(layer, function(v) {\r\n      var ws = neighborFn(v);\r\n      if (ws.length) {\r\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\r\n        var mp = (ws.length - 1) / 2;\r\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\r\n          var w = ws[i];\r\n          if (align[v] === v &&\r\n              prevIdx < pos[w] &&\r\n              !hasConflict(conflicts, v, w)) {\r\n            align[w] = v;\r\n            align[v] = root[v] = root[w];\r\n            prevIdx = pos[w];\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  return { root: root, align: align };\r\n}\r\n\r\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\r\n  // This portion of the algorithm differs from BK due to a number of problems.\r\n  // Instead of their algorithm we construct a new block graph and do two\r\n  // sweeps. The first sweep places blocks with the smallest possible\r\n  // coordinates. The second sweep removes unused space by moving blocks to the\r\n  // greatest coordinates without violating separation.\r\n  var xs = {},\r\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\r\n    borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\r\n\r\n  function iterate(setXsFunc, nextNodesFunc) {\r\n    var stack = blockG.nodes();\r\n    var elem = stack.pop();\r\n    var visited = {};\r\n    while (elem) {\r\n      if (visited[elem]) {\r\n        setXsFunc(elem);\r\n      } else {\r\n        visited[elem] = true;\r\n        stack.push(elem);\r\n        stack = stack.concat(nextNodesFunc(elem));\r\n      }\r\n\r\n      elem = stack.pop();\r\n    }\r\n  }\r\n\r\n  // First pass, assign smallest coordinates\r\n  function pass1(elem) {\r\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\r\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\r\n    }, 0);\r\n  }\r\n\r\n  // Second pass, assign greatest coordinates\r\n  function pass2(elem) {\r\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\r\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\r\n    }, Number.POSITIVE_INFINITY);\r\n\r\n    var node = g.node(elem);\r\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\r\n      xs[elem] = Math.max(xs[elem], min);\r\n    }\r\n  }\r\n\r\n  iterate(pass1, blockG.predecessors.bind(blockG));\r\n  iterate(pass2, blockG.successors.bind(blockG));\r\n\r\n  // Assign x coordinates to all nodes\r\n  _.forEach(align, function(v) {\r\n    xs[v] = xs[root[v]];\r\n  });\r\n\r\n  return xs;\r\n}\r\n\r\n\r\nfunction buildBlockGraph(g, layering, root, reverseSep) {\r\n  var blockGraph = new Graph(),\r\n    graphLabel = g.graph(),\r\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\r\n\r\n  _.forEach(layering, function(layer) {\r\n    var u;\r\n    _.forEach(layer, function(v) {\r\n      var vRoot = root[v];\r\n      blockGraph.setNode(vRoot);\r\n      if (u) {\r\n        var uRoot = root[u],\r\n          prevMax = blockGraph.edge(uRoot, vRoot);\r\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\r\n      }\r\n      u = v;\r\n    });\r\n  });\r\n\r\n  return blockGraph;\r\n}\r\n\r\n/*\r\n * Returns the alignment that has the smallest width of the given alignments.\r\n */\r\nfunction findSmallestWidthAlignment(g, xss) {\r\n  return _.minBy(_.values(xss), function (xs) {\r\n    var max = Number.NEGATIVE_INFINITY;\r\n    var min = Number.POSITIVE_INFINITY;\r\n\r\n    _.forIn(xs, function (x, v) {\r\n      var halfWidth = width(g, v) / 2;\r\n\r\n      max = Math.max(x + halfWidth, max);\r\n      min = Math.min(x - halfWidth, min);\r\n    });\r\n\r\n    return max - min;\r\n  });\r\n}\r\n\r\n/*\r\n * Align the coordinates of each of the layout alignments such that\r\n * left-biased alignments have their minimum coordinate at the same point as\r\n * the minimum coordinate of the smallest width alignment and right-biased\r\n * alignments have their maximum coordinate at the same point as the maximum\r\n * coordinate of the smallest width alignment.\r\n */\r\nfunction alignCoordinates(xss, alignTo) {\r\n  var alignToVals = _.values(alignTo),\r\n    alignToMin = _.min(alignToVals),\r\n    alignToMax = _.max(alignToVals);\r\n\r\n  _.forEach([\"u\", \"d\"], function(vert) {\r\n    _.forEach([\"l\", \"r\"], function(horiz) {\r\n      var alignment = vert + horiz,\r\n        xs = xss[alignment],\r\n        delta;\r\n      if (xs === alignTo) return;\r\n\r\n      var xsVals = _.values(xs);\r\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\r\n\r\n      if (delta) {\r\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction balance(xss, align) {\r\n  return _.mapValues(xss.ul, function(ignore, v) {\r\n    if (align) {\r\n      return xss[align.toLowerCase()][v];\r\n    } else {\r\n      var xs = _.sortBy(_.map(xss, v));\r\n      return (xs[1] + xs[2]) / 2;\r\n    }\r\n  });\r\n}\r\n\r\nfunction positionX(g) {\r\n  var layering = util.buildLayerMatrix(g);\r\n  var conflicts = _.merge(\r\n    findType1Conflicts(g, layering),\r\n    findType2Conflicts(g, layering));\r\n\r\n  var xss = {};\r\n  var adjustedLayering;\r\n  _.forEach([\"u\", \"d\"], function(vert) {\r\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\r\n    _.forEach([\"l\", \"r\"], function(horiz) {\r\n      if (horiz === \"r\") {\r\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\r\n          return _.values(inner).reverse();\r\n        });\r\n      }\r\n\r\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\r\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\r\n      var xs = horizontalCompaction(g, adjustedLayering,\r\n        align.root, align.align, horiz === \"r\");\r\n      if (horiz === \"r\") {\r\n        xs = _.mapValues(xs, function(x) { return -x; });\r\n      }\r\n      xss[vert + horiz] = xs;\r\n    });\r\n  });\r\n\r\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\r\n  alignCoordinates(xss, smallestWidth);\r\n  return balance(xss, g.graph().align);\r\n}\r\n\r\nfunction sep(nodeSep, edgeSep, reverseSep) {\r\n  return function(g, v, w) {\r\n    var vLabel = g.node(v);\r\n    var wLabel = g.node(w);\r\n    var sum = 0;\r\n    var delta;\r\n\r\n    sum += vLabel.width / 2;\r\n    if (_.has(vLabel, \"labelpos\")) {\r\n      switch (vLabel.labelpos.toLowerCase()) {\r\n      case \"l\": delta = -vLabel.width / 2; break;\r\n      case \"r\": delta = vLabel.width / 2; break;\r\n      }\r\n    }\r\n    if (delta) {\r\n      sum += reverseSep ? delta : -delta;\r\n    }\r\n    delta = 0;\r\n\r\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\r\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\r\n\r\n    sum += wLabel.width / 2;\r\n    if (_.has(wLabel, \"labelpos\")) {\r\n      switch (wLabel.labelpos.toLowerCase()) {\r\n      case \"l\": delta = wLabel.width / 2; break;\r\n      case \"r\": delta = -wLabel.width / 2; break;\r\n      }\r\n    }\r\n    if (delta) {\r\n      sum += reverseSep ? delta : -delta;\r\n    }\r\n    delta = 0;\r\n\r\n    return sum;\r\n  };\r\n}\r\n\r\nfunction width(g, v) {\r\n  return g.node(v).width;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}