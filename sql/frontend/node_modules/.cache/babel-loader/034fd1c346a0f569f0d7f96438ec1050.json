{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GADDIAsync = exports.getNeighborsAsync = exports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.detectCycleAsync = exports.getOutDegreeAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.connectedComponentAsync = exports.getAdjMatrixAsync = void 0;\n\nvar _createWorker = _interopRequireDefault(require(\"./createWorker\"));\n\nvar _constant = require(\"./constant\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\n\n\nvar getAdjMatrixAsync = function getAdjMatrixAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);\n};\n/**\r\n * 图的连通分量\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\n\n\nexports.getAdjMatrixAsync = getAdjMatrixAsync;\n\nvar connectedComponentAsync = function connectedComponentAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);\n};\n/**\r\n * 获取节点的度\r\n * @param graphData 图数据\r\n */\n\n\nexports.connectedComponentAsync = connectedComponentAsync;\n\nvar getDegreeAsync = function getDegreeAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);\n};\n/**\r\n * 获取节点的入度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\n\n\nexports.getDegreeAsync = getDegreeAsync;\n\nvar getInDegreeAsync = function getInDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);\n};\n/**\r\n * 获取节点的出度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\n\n\nexports.getInDegreeAsync = getInDegreeAsync;\n\nvar getOutDegreeAsync = function getOutDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);\n};\n/**\r\n * 检测图中的(有向) Cycle\r\n * @param graphData 图数据\r\n */\n\n\nexports.getOutDegreeAsync = getOutDegreeAsync;\n\nvar detectCycleAsync = function detectCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);\n};\n/**\r\n * 检测图中的(无向) Cycle\r\n * @param graphData 图数据\r\n */\n\n\nexports.detectCycleAsync = detectCycleAsync;\n\nvar detectAllCyclesAsync = function detectAllCyclesAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);\n};\n/**\r\n * 检测图中的所有(有向) Cycle\r\n * @param graphData 图数据\r\n */\n\n\nexports.detectAllCyclesAsync = detectAllCyclesAsync;\n\nvar detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);\n};\n/**\r\n * 检测图中的所有(无向) Cycle\r\n * @param graphData 图数据\r\n */\n\n\nexports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;\n\nvar detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);\n};\n/**\r\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\r\n * @param graphData 图数据\r\n */\n\n\nexports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;\n\nvar dijkstraAsync = function dijkstraAsync(graphData, source, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);\n};\n/**\r\n * 查找两点之间的所有路径\r\n * @param graphData 图数据\r\n * @param start 路径起始点ID\r\n * @param end 路径终点ID\r\n * @param directed 是否为有向图\r\n */\n\n\nexports.dijkstraAsync = dijkstraAsync;\n\nvar findAllPathAsync = function findAllPathAsync(graphData, start, end, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end, directed]);\n};\n/**\r\n * 查找两点之间的所有路径\r\n * @param graphData 图数据\r\n * @param start 路径起始点ID\r\n * @param end 路径终点ID\r\n * @param directed 是否为有向图\r\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\r\n */\n\n\nexports.findAllPathAsync = findAllPathAsync;\n\nvar findShortestPathAsync = function findShortestPathAsync(graphData, start, end, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end, directed, weightPropertyName]);\n};\n/**\r\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\n\n\nexports.findShortestPathAsync = findShortestPathAsync;\n\nvar floydWarshallAsync = function floydWarshallAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);\n};\n/**\r\n * 标签传播算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param maxIteration 最大迭代次数\r\n */\n\n\nexports.floydWarshallAsync = floydWarshallAsync;\n\nvar labelPropagationAsync = function labelPropagationAsync(graphData, directed, weightPropertyName, maxIteration) {\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);\n};\n/**\r\n * 社区发现 louvain 算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param threshold\r\n */\n\n\nexports.labelPropagationAsync = labelPropagationAsync;\n\nvar louvainAsync = function louvainAsync(graphData, directed, weightPropertyName, threshold) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\n};\n/**\r\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\r\n * @param graph\r\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\r\n * @param algo 'prim' | 'kruskal' 算法类型\r\n * @return EdgeConfig[] 返回构成MST的边的数组\r\n */\n\n\nexports.louvainAsync = louvainAsync;\n\nvar minimumSpanningTreeAsync = function minimumSpanningTreeAsync(graphData, weight, algo) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);\n};\n/**\r\n * PageRank https://en.wikipedia.org/wiki/PageRank\r\n * refer: https://github.com/anvaka/ngraph.pagerank\r\n * @param graph\r\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\r\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\r\n */\n\n\nexports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;\n\nvar pageRankAsync = function pageRankAsync(graphData, epsilon, linkProb) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);\n};\n/**\r\n * 获取指定节点的所有邻居\r\n * @param nodeId 节点 ID\r\n * @param edges 图中的所有边数据\r\n * @param type 邻居类型\r\n */\n\n\nexports.pageRankAsync = pageRankAsync;\n\nvar getNeighborsAsync = function getNeighborsAsync(nodeId, edges, type) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);\n};\n/**\r\n * GADDI 图模式匹配\r\n * @param graphData 原图数据\r\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\r\n * @param directed 是否计算有向图，默认 false\r\n * @param k 参数 k，表示 k-近邻\r\n * @param length 参数 length\r\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\r\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\r\n */\n\n\nexports.getNeighborsAsync = getNeighborsAsync;\n\nvar GADDIAsync = function GADDIAsync(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp]);\n};\n\nexports.GADDIAsync = GADDIAsync;","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/@antv/algorithm/lib/workers/index.js"],"names":["Object","defineProperty","exports","value","GADDIAsync","getNeighborsAsync","pageRankAsync","minimumSpanningTreeAsync","louvainAsync","labelPropagationAsync","floydWarshallAsync","findShortestPathAsync","findAllPathAsync","dijkstraAsync","detectAllUndirectedCycleAsync","detectAllDirectedCycleAsync","detectAllCyclesAsync","detectCycleAsync","getOutDegreeAsync","getInDegreeAsync","getDegreeAsync","connectedComponentAsync","getAdjMatrixAsync","_createWorker","_interopRequireDefault","require","_constant","obj","__esModule","default","graphData","directed","ALGORITHM","getAdjMatrix","apply","connectedComponent","getDegree","nodeId","getInDegree","getOutDegree","detectCycle","detectAllCycles","detectAllDirectedCycle","detectAllUndirectedCycle","source","weightPropertyName","dijkstra","start","end","findAllPath","findShortestPath","floydWarshall","maxIteration","labelPropagation","threshold","louvain","weight","algo","minimumSpanningTree","epsilon","linkProb","pageRank","edges","type","getNeighbors","pattern","k","length","nodeLabelProp","edgeLabelProp","GADDI"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.GADDIAsync = exports.getNeighborsAsync = exports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.detectCycleAsync = exports.getOutDegreeAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.connectedComponentAsync = exports.getAdjMatrixAsync = void 0;\r\n\r\nvar _createWorker = _interopRequireDefault(require(\"./createWorker\"));\r\n\r\nvar _constant = require(\"./constant\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\r\nvar getAdjMatrixAsync = function getAdjMatrixAsync(graphData, directed) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);\r\n};\r\n/**\r\n * 图的连通分量\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\r\n\r\n\r\nexports.getAdjMatrixAsync = getAdjMatrixAsync;\r\n\r\nvar connectedComponentAsync = function connectedComponentAsync(graphData, directed) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);\r\n};\r\n/**\r\n * 获取节点的度\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.connectedComponentAsync = connectedComponentAsync;\r\n\r\nvar getDegreeAsync = function getDegreeAsync(graphData) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);\r\n};\r\n/**\r\n * 获取节点的入度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\r\n\r\n\r\nexports.getDegreeAsync = getDegreeAsync;\r\n\r\nvar getInDegreeAsync = function getInDegreeAsync(graphData, nodeId) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);\r\n};\r\n/**\r\n * 获取节点的出度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\r\n\r\n\r\nexports.getInDegreeAsync = getInDegreeAsync;\r\n\r\nvar getOutDegreeAsync = function getOutDegreeAsync(graphData, nodeId) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);\r\n};\r\n/**\r\n * 检测图中的(有向) Cycle\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.getOutDegreeAsync = getOutDegreeAsync;\r\n\r\nvar detectCycleAsync = function detectCycleAsync(graphData) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);\r\n};\r\n/**\r\n * 检测图中的(无向) Cycle\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.detectCycleAsync = detectCycleAsync;\r\n\r\nvar detectAllCyclesAsync = function detectAllCyclesAsync(graphData) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);\r\n};\r\n/**\r\n * 检测图中的所有(有向) Cycle\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.detectAllCyclesAsync = detectAllCyclesAsync;\r\n\r\nvar detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync(graphData) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);\r\n};\r\n/**\r\n * 检测图中的所有(无向) Cycle\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;\r\n\r\nvar detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync(graphData) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);\r\n};\r\n/**\r\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;\r\n\r\nvar dijkstraAsync = function dijkstraAsync(graphData, source, directed, weightPropertyName) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);\r\n};\r\n/**\r\n * 查找两点之间的所有路径\r\n * @param graphData 图数据\r\n * @param start 路径起始点ID\r\n * @param end 路径终点ID\r\n * @param directed 是否为有向图\r\n */\r\n\r\n\r\nexports.dijkstraAsync = dijkstraAsync;\r\n\r\nvar findAllPathAsync = function findAllPathAsync(graphData, start, end, directed) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end, directed]);\r\n};\r\n/**\r\n * 查找两点之间的所有路径\r\n * @param graphData 图数据\r\n * @param start 路径起始点ID\r\n * @param end 路径终点ID\r\n * @param directed 是否为有向图\r\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\r\n */\r\n\r\n\r\nexports.findAllPathAsync = findAllPathAsync;\r\n\r\nvar findShortestPathAsync = function findShortestPathAsync(graphData, start, end, directed, weightPropertyName) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end, directed, weightPropertyName]);\r\n};\r\n/**\r\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\r\n * @param graphData 图数据\r\n * @param directed 是否为有向图\r\n */\r\n\r\n\r\nexports.findShortestPathAsync = findShortestPathAsync;\r\n\r\nvar floydWarshallAsync = function floydWarshallAsync(graphData, directed) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);\r\n};\r\n/**\r\n * 标签传播算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param maxIteration 最大迭代次数\r\n */\r\n\r\n\r\nexports.floydWarshallAsync = floydWarshallAsync;\r\n\r\nvar labelPropagationAsync = function labelPropagationAsync(graphData, directed, weightPropertyName, maxIteration) {\r\n  if (maxIteration === void 0) {\r\n    maxIteration = 1000;\r\n  }\r\n\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);\r\n};\r\n/**\r\n * 社区发现 louvain 算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param threshold\r\n */\r\n\r\n\r\nexports.labelPropagationAsync = labelPropagationAsync;\r\n\r\nvar louvainAsync = function louvainAsync(graphData, directed, weightPropertyName, threshold) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\r\n};\r\n/**\r\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\r\n * @param graph\r\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\r\n * @param algo 'prim' | 'kruskal' 算法类型\r\n * @return EdgeConfig[] 返回构成MST的边的数组\r\n */\r\n\r\n\r\nexports.louvainAsync = louvainAsync;\r\n\r\nvar minimumSpanningTreeAsync = function minimumSpanningTreeAsync(graphData, weight, algo) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);\r\n};\r\n/**\r\n * PageRank https://en.wikipedia.org/wiki/PageRank\r\n * refer: https://github.com/anvaka/ngraph.pagerank\r\n * @param graph\r\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\r\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\r\n */\r\n\r\n\r\nexports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;\r\n\r\nvar pageRankAsync = function pageRankAsync(graphData, epsilon, linkProb) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);\r\n};\r\n/**\r\n * 获取指定节点的所有邻居\r\n * @param nodeId 节点 ID\r\n * @param edges 图中的所有边数据\r\n * @param type 邻居类型\r\n */\r\n\r\n\r\nexports.pageRankAsync = pageRankAsync;\r\n\r\nvar getNeighborsAsync = function getNeighborsAsync(nodeId, edges, type) {\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);\r\n};\r\n/**\r\n * GADDI 图模式匹配\r\n * @param graphData 原图数据\r\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\r\n * @param directed 是否计算有向图，默认 false\r\n * @param k 参数 k，表示 k-近邻\r\n * @param length 参数 length\r\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\r\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\r\n */\r\n\r\n\r\nexports.getNeighborsAsync = getNeighborsAsync;\r\n\r\nvar GADDIAsync = function GADDIAsync(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (nodeLabelProp === void 0) {\r\n    nodeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (edgeLabelProp === void 0) {\r\n    edgeLabelProp = 'cluster';\r\n  }\r\n\r\n  return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp]);\r\n};\r\n\r\nexports.GADDIAsync = GADDIAsync;"]},"metadata":{},"sourceType":"script"}