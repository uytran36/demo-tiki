{"ast":null,"code":"import { each, isNil } from '@antv/util';\nimport { ellipsisString, strLen } from './text';\nvar ELLIPSIS_CODE = '\\u2026';\nvar ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\n\n/** 大数据量阈值 */\n\nvar OPTIMIZE_THRESHOLD = 400;\n/**\r\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\r\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\r\n * 最终是去字符串最“长”的那个 label 的宽度。\r\n * @param labels\r\n */\n\nfunction getMaxLabelWidthOptimized(labels) {\n  var texts = labels.map(function (label) {\n    var text = label.attr('text');\n    return isNil(text) ? '' : \"\" + text;\n  });\n  var maxLen = 0;\n  var maxIdx = 0;\n\n  for (var i = 0; i < texts.length; i += 1) {\n    var len = 0;\n\n    for (var j = 0; j <= texts[i].length; j += 1) {\n      var code = texts[i].charCodeAt(j);\n\n      if (code >= 19968 && code <= 40869) {\n        len += 2;\n      } else {\n        len += 1;\n      }\n    }\n\n    if (len > maxLen) {\n      maxLen = len;\n      maxIdx = i;\n    }\n  }\n\n  return labels[maxIdx].getBBox().width;\n}\n/** 获取最长的 label */\n\n\nexport function getMaxLabelWidth(labels) {\n  if (labels.length > OPTIMIZE_THRESHOLD) {\n    return getMaxLabelWidthOptimized(labels);\n  }\n\n  var max = 0;\n  each(labels, function (label) {\n    var bbox = label.getBBox();\n    var width = bbox.width;\n\n    if (max < width) {\n      max = width;\n    }\n  });\n  return max;\n}\n/** 获取label长度 */\n\nexport function getLabelLength(isVertical, label) {\n  var bbox = label.getCanvasBBox();\n  return isVertical ? bbox.width : bbox.height;\n}\n/* label长度是否超过约束值 */\n\nexport function testLabel(label, limitLength) {\n  return label.getBBox().width < limitLength;\n}\n/** 处理 text shape 的自动省略 */\n\nexport function ellipsisLabel(isVertical, label, limitLength, position) {\n  if (position === void 0) {\n    position = 'tail';\n  }\n\n  var text = label.attr('text');\n  var labelLength = getLabelLength(isVertical, label);\n  var codeLength = strLen(text);\n  var ellipsised = false;\n\n  if (limitLength < labelLength) {\n    var reseveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\n\n    var newText = void 0;\n\n    if (reseveLength >= 0) {\n      newText = ellipsisString(text, reseveLength, position);\n    } else {\n      newText = ELLIPSIS_CODE;\n    }\n\n    if (newText) {\n      label.attr('text', newText);\n      ellipsised = true;\n    }\n  }\n\n  if (ellipsised) {\n    label.set('tip', text);\n  } else {\n    label.set('tip', null);\n  }\n\n  return ellipsised;\n}","map":{"version":3,"sources":["../../src/util/label.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { each, isNil } from '@antv/util';\r\nimport { ellipsisString, strLen } from './text';\r\nvar ELLIPSIS_CODE = '\\u2026';\r\nvar ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\r\n/** 大数据量阈值 */\r\nvar OPTIMIZE_THRESHOLD = 400;\r\n/**\r\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\r\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\r\n * 最终是去字符串最“长”的那个 label 的宽度。\r\n * @param labels\r\n */\r\nfunction getMaxLabelWidthOptimized(labels) {\r\n    var texts = labels.map(function (label) {\r\n        var text = label.attr('text');\r\n        return isNil(text) ? '' : \"\" + text;\r\n    });\r\n    var maxLen = 0;\r\n    var maxIdx = 0;\r\n    for (var i = 0; i < texts.length; i += 1) {\r\n        var len = 0;\r\n        for (var j = 0; j <= texts[i].length; j += 1) {\r\n            var code = texts[i].charCodeAt(j);\r\n            if (code >= 19968 && code <= 40869) {\r\n                len += 2;\r\n            }\r\n            else {\r\n                len += 1;\r\n            }\r\n        }\r\n        if (len > maxLen) {\r\n            maxLen = len;\r\n            maxIdx = i;\r\n        }\r\n    }\r\n    return labels[maxIdx].getBBox().width;\r\n}\r\n/** 获取最长的 label */\r\nexport function getMaxLabelWidth(labels) {\r\n    if (labels.length > OPTIMIZE_THRESHOLD) {\r\n        return getMaxLabelWidthOptimized(labels);\r\n    }\r\n    var max = 0;\r\n    each(labels, function (label) {\r\n        var bbox = label.getBBox();\r\n        var width = bbox.width;\r\n        if (max < width) {\r\n            max = width;\r\n        }\r\n    });\r\n    return max;\r\n}\r\n/** 获取label长度 */\r\nexport function getLabelLength(isVertical, label) {\r\n    var bbox = label.getCanvasBBox();\r\n    return isVertical ? bbox.width : bbox.height;\r\n}\r\n/* label长度是否超过约束值 */\r\nexport function testLabel(label, limitLength) {\r\n    return label.getBBox().width < limitLength;\r\n}\r\n/** 处理 text shape 的自动省略 */\r\nexport function ellipsisLabel(isVertical, label, limitLength, position) {\r\n    if (position === void 0) { position = 'tail'; }\r\n    var text = label.attr('text');\r\n    var labelLength = getLabelLength(isVertical, label);\r\n    var codeLength = strLen(text);\r\n    var ellipsised = false;\r\n    if (limitLength < labelLength) {\r\n        var reseveLength = Math.floor((limitLength / labelLength) * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\r\n        var newText = void 0;\r\n        if (reseveLength >= 0) {\r\n            newText = ellipsisString(text, reseveLength, position);\r\n        }\r\n        else {\r\n            newText = ELLIPSIS_CODE;\r\n        }\r\n        if (newText) {\r\n            label.attr('text', newText);\r\n            ellipsised = true;\r\n        }\r\n    }\r\n    if (ellipsised) {\r\n        label.set('tip', text);\r\n    }\r\n    else {\r\n        label.set('tip', null);\r\n    }\r\n    return ellipsised;\r\n}\r\n//# sourceMappingURL=label.js.map"]},"metadata":{},"sourceType":"module"}