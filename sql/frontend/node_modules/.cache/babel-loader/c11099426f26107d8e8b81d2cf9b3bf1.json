{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { catmullRom2Bezier } from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { each, head, isEqual, map } from '@antv/util';\n/**\r\n * 点数组转 path\r\n * @param points\r\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\r\n * 将点连接成路径 path\r\n * @param points\r\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\r\n * 将点连成平滑的曲线\r\n * @param points\r\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  }); // const constraint = [ // 范围\n  //   [ 0, 0 ],\n  //   [ 1, 1 ],\n  // ];\n\n  var path = catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\r\n * 将数据转成 path，利用 scale 的归一化能力\r\n * @param data\r\n * @param width\r\n * @param height\r\n * @param smooth\r\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\n/**\r\n * 获得 area 面积的横向连接线的 px 位置\r\n * @param data\r\n * @param width\r\n * @param height\r\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\r\n * 线 path 转 area path\r\n * @param path\r\n * @param width\r\n * @param height\r\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArrays(path);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}","map":{"version":3,"sources":["../../src/trend/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __spreadArrays } from \"tslib\";\r\nimport { catmullRom2Bezier } from '@antv/path-util';\r\nimport { Category, Linear } from '@antv/scale';\r\nimport { each, head, isEqual, map } from '@antv/util';\r\n/**\r\n * 点数组转 path\r\n * @param points\r\n */\r\nfunction pointsToPath(points) {\r\n    return map(points, function (p, idx) {\r\n        var command = idx === 0 ? 'M' : 'L';\r\n        var x = p[0], y = p[1];\r\n        return [command, x, y];\r\n    });\r\n}\r\n/**\r\n * 将点连接成路径 path\r\n * @param points\r\n */\r\nexport function getLinePath(points) {\r\n    return pointsToPath(points);\r\n}\r\n/**\r\n * 将点连成平滑的曲线\r\n * @param points\r\n */\r\nexport function getSmoothLinePath(points) {\r\n    if (points.length <= 2) {\r\n        // 两点以内直接绘制成路径\r\n        return getLinePath(points);\r\n    }\r\n    var data = [];\r\n    each(points, function (p) {\r\n        // 当前点和上一个点一样的时候，忽略掉\r\n        if (!isEqual(p, data.slice(data.length - 2))) {\r\n            data.push(p[0], p[1]);\r\n        }\r\n    });\r\n    // const constraint = [ // 范围\r\n    //   [ 0, 0 ],\r\n    //   [ 1, 1 ],\r\n    // ];\r\n    var path = catmullRom2Bezier(data, false);\r\n    var _a = head(points), x = _a[0], y = _a[1];\r\n    path.unshift(['M', x, y]);\r\n    return path;\r\n}\r\n/**\r\n * 将数据转成 path，利用 scale 的归一化能力\r\n * @param data\r\n * @param width\r\n * @param height\r\n * @param smooth\r\n */\r\nexport function dataToPath(data, width, height, smooth) {\r\n    if (smooth === void 0) { smooth = true; }\r\n    // 利用 scale 来获取 y 上的映射\r\n    var y = new Linear({\r\n        values: data,\r\n    });\r\n    var x = new Category({\r\n        values: map(data, function (v, idx) { return idx; }),\r\n    });\r\n    var points = map(data, function (v, idx) {\r\n        return [x.scale(idx) * width, height - y.scale(v) * height];\r\n    });\r\n    return smooth ? getSmoothLinePath(points) : getLinePath(points);\r\n}\r\n/**\r\n * 获得 area 面积的横向连接线的 px 位置\r\n * @param data\r\n * @param width\r\n * @param height\r\n */\r\nexport function getAreaLineY(data, height) {\r\n    var y = new Linear({\r\n        values: data,\r\n    });\r\n    var lineY = Math.max(0, y.min);\r\n    return height - y.scale(lineY) * height;\r\n}\r\n/**\r\n * 线 path 转 area path\r\n * @param path\r\n * @param width\r\n * @param height\r\n */\r\nexport function linePathToAreaPath(path, width, height, data) {\r\n    var areaPath = __spreadArrays(path);\r\n    var lineYPx = getAreaLineY(data, height);\r\n    areaPath.push(['L', width, lineYPx]);\r\n    areaPath.push(['L', 0, lineYPx]);\r\n    areaPath.push(['Z']);\r\n    return areaPath;\r\n}\r\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}