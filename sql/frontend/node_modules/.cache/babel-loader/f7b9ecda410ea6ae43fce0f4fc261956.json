{"ast":null,"code":"import { isObject } from './object';\nexport const getEdgeTerminal = (edge, type) => {\n  const terminal = edge[type];\n\n  if (isObject(terminal)) {\n    return terminal.cell;\n  }\n\n  return terminal;\n};\nexport const getDegree = (n, nodeIdxMap, edges) => {\n  const degrees = [];\n\n  for (let i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  if (!edges) return degrees;\n  edges.forEach(e => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n\n    if (source) {\n      degrees[nodeIdxMap[source]] += 1;\n    }\n\n    if (target) {\n      degrees[nodeIdxMap[target]] += 1;\n    }\n  });\n  return degrees;\n};\nexport const floydWarshall = adjMatrix => {\n  // initialize\n  const dist = [];\n  const size = adjMatrix.length;\n\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix = []; // map node with index in data.nodes\n\n  const nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      const sIndex = nodeMap[source];\n      const tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\r\n * scale matrix\r\n * @param matrix [ [], [], [] ]\r\n * @param ratio\r\n */\n\nexport const scaleMatrix = (matrix, ratio) => {\n  const result = [];\n  matrix.forEach(row => {\n    const newRow = [];\n    row.forEach(v => {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n *  if the fn returns false, terminate the traverse\r\n */\n\nconst traverseUp = (data, fn) => {\n  if (data && data.children) {\n    for (let i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n * if the fn returns false, terminate the traverse\r\n */\n\n\nexport const traverseTreeUp = (data, fn) => {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isObject } from './object';\r\nexport const getEdgeTerminal = (edge, type) => {\r\n    const terminal = edge[type];\r\n    if (isObject(terminal)) {\r\n        return terminal.cell;\r\n    }\r\n    return terminal;\r\n};\r\nexport const getDegree = (n, nodeIdxMap, edges) => {\r\n    const degrees = [];\r\n    for (let i = 0; i < n; i++) {\r\n        degrees[i] = 0;\r\n    }\r\n    if (!edges)\r\n        return degrees;\r\n    edges.forEach((e) => {\r\n        const source = getEdgeTerminal(e, 'source');\r\n        const target = getEdgeTerminal(e, 'target');\r\n        if (source) {\r\n            degrees[nodeIdxMap[source]] += 1;\r\n        }\r\n        if (target) {\r\n            degrees[nodeIdxMap[target]] += 1;\r\n        }\r\n    });\r\n    return degrees;\r\n};\r\nexport const floydWarshall = (adjMatrix) => {\r\n    // initialize\r\n    const dist = [];\r\n    const size = adjMatrix.length;\r\n    for (let i = 0; i < size; i += 1) {\r\n        dist[i] = [];\r\n        for (let j = 0; j < size; j += 1) {\r\n            if (i === j) {\r\n                dist[i][j] = 0;\r\n            }\r\n            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\r\n                dist[i][j] = Infinity;\r\n            }\r\n            else {\r\n                dist[i][j] = adjMatrix[i][j];\r\n            }\r\n        }\r\n    }\r\n    // floyd\r\n    for (let k = 0; k < size; k += 1) {\r\n        for (let i = 0; i < size; i += 1) {\r\n            for (let j = 0; j < size; j += 1) {\r\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n                    dist[i][j] = dist[i][k] + dist[k][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dist;\r\n};\r\nexport const getAdjMatrix = (data, directed) => {\r\n    const { nodes, edges } = data;\r\n    const matrix = [];\r\n    // map node with index in data.nodes\r\n    const nodeMap = {};\r\n    if (!nodes) {\r\n        throw new Error('invalid nodes data!');\r\n    }\r\n    if (nodes) {\r\n        nodes.forEach((node, i) => {\r\n            nodeMap[node.id] = i;\r\n            const row = [];\r\n            matrix.push(row);\r\n        });\r\n    }\r\n    if (edges) {\r\n        edges.forEach((e) => {\r\n            const source = getEdgeTerminal(e, 'source');\r\n            const target = getEdgeTerminal(e, 'target');\r\n            const sIndex = nodeMap[source];\r\n            const tIndex = nodeMap[target];\r\n            matrix[sIndex][tIndex] = 1;\r\n            if (!directed) {\r\n                matrix[tIndex][sIndex] = 1;\r\n            }\r\n        });\r\n    }\r\n    return matrix;\r\n};\r\n/**\r\n * scale matrix\r\n * @param matrix [ [], [], [] ]\r\n * @param ratio\r\n */\r\nexport const scaleMatrix = (matrix, ratio) => {\r\n    const result = [];\r\n    matrix.forEach((row) => {\r\n        const newRow = [];\r\n        row.forEach((v) => {\r\n            newRow.push(v * ratio);\r\n        });\r\n        result.push(newRow);\r\n    });\r\n    return result;\r\n};\r\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n *  if the fn returns false, terminate the traverse\r\n */\r\nconst traverseUp = (data, fn) => {\r\n    if (data && data.children) {\r\n        for (let i = data.children.length - 1; i >= 0; i--) {\r\n            if (!traverseUp(data.children[i], fn))\r\n                return;\r\n        }\r\n    }\r\n    if (!fn(data)) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n * if the fn returns false, terminate the traverse\r\n */\r\nexport const traverseTreeUp = (data, fn) => {\r\n    if (typeof fn !== 'function') {\r\n        return;\r\n    }\r\n    traverseUp(data, fn);\r\n};\r\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}