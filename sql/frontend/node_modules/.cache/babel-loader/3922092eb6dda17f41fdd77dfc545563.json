{"ast":null,"code":"/**\r\n * @fileOverview random layout\r\n * @author shiwu.wyy@antfin.com\r\n */\nimport { Base } from \"./base\";\nimport { getDegree, clone, getEdgeTerminal } from \"../util\";\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach((_, i) => {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      let targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      const child = nodes[sourceIdx].children;\n      const parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      let targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      const sourceChildren = nodes[sourceIdx].children;\n      const targetChildren = nodes[targetIdx].children;\n      sourceChildren.push(nodes[targetIdx].id);\n      targetChildren.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  const m = edges.length;\n\n  for (let i = 0; i < m; i++) {\n    const source = getEdgeTerminal(edges[i], 'source');\n    const target = getEdgeTerminal(edges[i], 'target');\n\n    if (a.id === source && b.id === target || b.id === source && a.id === target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  const aDegree = a.degree;\n  const bDegree = b.degree;\n\n  if (aDegree < bDegree) {\n    return -1;\n  }\n\n  if (aDegree > bDegree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\r\n * 圆形布局\r\n */\n\n\nexport class CircularLayout extends Base {\n  constructor(options) {\n    super();\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    this.radius = null;\n    /** 起始半径 */\n\n    this.startRadius = null;\n    /** 终止半径 */\n\n    this.endRadius = null;\n    /** 起始角度 */\n\n    this.startAngle = 0;\n    /** 终止角度 */\n\n    this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    this.angleRatio = 1;\n    this.nodes = [];\n    this.edges = [];\n    this.nodeMap = {};\n    this.degrees = [];\n    this.width = 300;\n    this.height = 300;\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  }\n  /**\r\n   * 执行布局\r\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    const center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    let radius = self.radius;\n    let startRadius = self.startRadius;\n    let endRadius = self.endRadius;\n    const divisions = self.divisions;\n    const startAngle = self.startAngle;\n    const endAngle = self.endAngle;\n    const angleStep = (endAngle - startAngle) / n; // layout\n\n    const nodeMap = {};\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    const degrees = getDegree(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n\n    if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n\n    const angleRatio = self.angleRatio;\n    const astep = angleStep * angleRatio;\n    const ordering = self.ordering;\n    let layoutNodes = [];\n\n    if (ordering === \"topology\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === \"topology-directed\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === \"degree\") {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    const clockwise = self.clockwise;\n    const divN = Math.ceil(n / divisions); // node number in each division\n\n    for (let i = 0; i < n; ++i) {\n      let r = radius;\n\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + i * (endRadius - startRadius) / (n - 1);\n      }\n\n      if (!r) {\n        r = 10 + i * 100 / (n - 1);\n      }\n\n      let angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n      if (!clockwise) {\n        angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n      }\n\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i];\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: layoutNodes,\n      edges: this.edges\n    };\n  }\n  /**\r\n   * 根据节点的拓扑结构排序\r\n   * @return {array} orderedNodes 排序后的结果\r\n   */\n\n\n  topologyOrdering(directed = false) {\n    const self = this;\n    const degrees = self.degrees;\n    const edges = self.edges;\n    const nodes = self.nodes;\n    const cnodes = clone(nodes);\n    const nodeMap = self.nodeMap;\n    const orderedCNodes = [cnodes[0]];\n    const resNodes = [nodes[0]];\n    const pickFlags = [];\n    const n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    let k = 0;\n    cnodes.forEach((cnode, i) => {\n      if (i !== 0) {\n        if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && !pickFlags[i]) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          const children = orderedCNodes[k].children;\n          let foundChild = false;\n\n          for (let j = 0; j < children.length; j++) {\n            const childIdx = nodeMap[children[j]];\n\n            if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n\n          let ii = 0;\n\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n\n            ii++;\n\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  }\n  /**\r\n   * 根据节点度数大小排序\r\n   * @return {array} orderedNodes 排序后的结果\r\n   */\n\n\n  degreeOrdering() {\n    const self = this;\n    const nodes = self.nodes;\n    const orderedNodes = [];\n    const degrees = self.degrees;\n    nodes.forEach((node, i) => {\n      node.degree = degrees[i];\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  }\n\n  getType() {\n    return \"circular\";\n  }\n\n}","map":{"version":3,"sources":["../../src/layout/circular.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @fileOverview random layout\r\n * @author shiwu.wyy@antfin.com\r\n */\r\nimport { Base } from \"./base\";\r\nimport { getDegree, clone, getEdgeTerminal } from \"../util\";\r\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\r\n    nodes.forEach((_, i) => {\r\n        nodes[i].children = [];\r\n        nodes[i].parent = [];\r\n    });\r\n    if (directed) {\r\n        edges.forEach((e) => {\r\n            const source = getEdgeTerminal(e, 'source');\r\n            const target = getEdgeTerminal(e, 'target');\r\n            let sourceIdx = 0;\r\n            if (source) {\r\n                sourceIdx = nodeMap[source];\r\n            }\r\n            let targetIdx = 0;\r\n            if (target) {\r\n                targetIdx = nodeMap[target];\r\n            }\r\n            const child = nodes[sourceIdx].children;\r\n            const parent = nodes[targetIdx].parent;\r\n            child.push(nodes[targetIdx].id);\r\n            parent.push(nodes[sourceIdx].id);\r\n        });\r\n    }\r\n    else {\r\n        edges.forEach((e) => {\r\n            const source = getEdgeTerminal(e, 'source');\r\n            const target = getEdgeTerminal(e, 'target');\r\n            let sourceIdx = 0;\r\n            if (source) {\r\n                sourceIdx = nodeMap[source];\r\n            }\r\n            let targetIdx = 0;\r\n            if (target) {\r\n                targetIdx = nodeMap[target];\r\n            }\r\n            const sourceChildren = nodes[sourceIdx].children;\r\n            const targetChildren = nodes[targetIdx].children;\r\n            sourceChildren.push(nodes[targetIdx].id);\r\n            targetChildren.push(nodes[sourceIdx].id);\r\n        });\r\n    }\r\n}\r\nfunction connect(a, b, edges) {\r\n    const m = edges.length;\r\n    for (let i = 0; i < m; i++) {\r\n        const source = getEdgeTerminal(edges[i], 'source');\r\n        const target = getEdgeTerminal(edges[i], 'target');\r\n        if ((a.id === source && b.id === target) ||\r\n            (b.id === source && a.id === target)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction compareDegree(a, b) {\r\n    const aDegree = a.degree;\r\n    const bDegree = b.degree;\r\n    if (aDegree < bDegree) {\r\n        return -1;\r\n    }\r\n    if (aDegree > bDegree) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * 圆形布局\r\n */\r\nexport class CircularLayout extends Base {\r\n    constructor(options) {\r\n        super();\r\n        /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\r\n        this.radius = null;\r\n        /** 起始半径 */\r\n        this.startRadius = null;\r\n        /** 终止半径 */\r\n        this.endRadius = null;\r\n        /** 起始角度 */\r\n        this.startAngle = 0;\r\n        /** 终止角度 */\r\n        this.endAngle = 2 * Math.PI;\r\n        /** 是否顺时针 */\r\n        this.clockwise = true;\r\n        /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\r\n        this.divisions = 1;\r\n        /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\r\n        this.ordering = null;\r\n        /** how many 2*pi from first to last nodes */\r\n        this.angleRatio = 1;\r\n        this.nodes = [];\r\n        this.edges = [];\r\n        this.nodeMap = {};\r\n        this.degrees = [];\r\n        this.width = 300;\r\n        this.height = 300;\r\n        this.updateCfg(options);\r\n    }\r\n    getDefaultCfg() {\r\n        return {\r\n            radius: null,\r\n            startRadius: null,\r\n            endRadius: null,\r\n            startAngle: 0,\r\n            endAngle: 2 * Math.PI,\r\n            clockwise: true,\r\n            divisions: 1,\r\n            ordering: null,\r\n            angleRatio: 1\r\n        };\r\n    }\r\n    /**\r\n     * 执行布局\r\n     */\r\n    execute() {\r\n        const self = this;\r\n        const nodes = self.nodes;\r\n        const edges = self.edges;\r\n        const n = nodes.length;\r\n        if (n === 0) {\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return;\r\n        }\r\n        if (!self.width && typeof window !== \"undefined\") {\r\n            self.width = window.innerWidth;\r\n        }\r\n        if (!self.height && typeof window !== \"undefined\") {\r\n            self.height = window.innerHeight;\r\n        }\r\n        if (!self.center) {\r\n            self.center = [self.width / 2, self.height / 2];\r\n        }\r\n        const center = self.center;\r\n        if (n === 1) {\r\n            nodes[0].x = center[0];\r\n            nodes[0].y = center[1];\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return;\r\n        }\r\n        let radius = self.radius;\r\n        let startRadius = self.startRadius;\r\n        let endRadius = self.endRadius;\r\n        const divisions = self.divisions;\r\n        const startAngle = self.startAngle;\r\n        const endAngle = self.endAngle;\r\n        const angleStep = (endAngle - startAngle) / n;\r\n        // layout\r\n        const nodeMap = {};\r\n        nodes.forEach((node, i) => {\r\n            nodeMap[node.id] = i;\r\n        });\r\n        self.nodeMap = nodeMap;\r\n        const degrees = getDegree(nodes.length, nodeMap, edges);\r\n        self.degrees = degrees;\r\n        if (!radius && !startRadius && !endRadius) {\r\n            radius = self.height > self.width ? self.width / 2 : self.height / 2;\r\n        }\r\n        else if (!startRadius && endRadius) {\r\n            startRadius = endRadius;\r\n        }\r\n        else if (startRadius && !endRadius) {\r\n            endRadius = startRadius;\r\n        }\r\n        const angleRatio = self.angleRatio;\r\n        const astep = angleStep * angleRatio;\r\n        const ordering = self.ordering;\r\n        let layoutNodes = [];\r\n        if (ordering === \"topology\") {\r\n            // layout according to the topology\r\n            layoutNodes = self.topologyOrdering();\r\n        }\r\n        else if (ordering === \"topology-directed\") {\r\n            // layout according to the topology\r\n            layoutNodes = self.topologyOrdering(true);\r\n        }\r\n        else if (ordering === \"degree\") {\r\n            // layout according to the descent order of degrees\r\n            layoutNodes = self.degreeOrdering();\r\n        }\r\n        else {\r\n            // layout according to the original order in the data.nodes\r\n            layoutNodes = nodes;\r\n        }\r\n        const clockwise = self.clockwise;\r\n        const divN = Math.ceil(n / divisions); // node number in each division\r\n        for (let i = 0; i < n; ++i) {\r\n            let r = radius;\r\n            if (!r && startRadius !== null && endRadius !== null) {\r\n                r = startRadius + (i * (endRadius - startRadius)) / (n - 1);\r\n            }\r\n            if (!r) {\r\n                r = 10 + (i * 100) / (n - 1);\r\n            }\r\n            let angle = startAngle +\r\n                (i % divN) * astep +\r\n                ((2 * Math.PI) / divisions) * Math.floor(i / divN);\r\n            if (!clockwise) {\r\n                angle =\r\n                    endAngle -\r\n                        (i % divN) * astep -\r\n                        ((2 * Math.PI) / divisions) * Math.floor(i / divN);\r\n            }\r\n            layoutNodes[i].x = center[0] + Math.cos(angle) * r;\r\n            layoutNodes[i].y = center[1] + Math.sin(angle) * r;\r\n            layoutNodes[i].weight = degrees[i];\r\n        }\r\n        if (self.onLayoutEnd)\r\n            self.onLayoutEnd();\r\n        return {\r\n            nodes: layoutNodes,\r\n            edges: this.edges\r\n        };\r\n    }\r\n    /**\r\n     * 根据节点的拓扑结构排序\r\n     * @return {array} orderedNodes 排序后的结果\r\n     */\r\n    topologyOrdering(directed = false) {\r\n        const self = this;\r\n        const degrees = self.degrees;\r\n        const edges = self.edges;\r\n        const nodes = self.nodes;\r\n        const cnodes = clone(nodes);\r\n        const nodeMap = self.nodeMap;\r\n        const orderedCNodes = [cnodes[0]];\r\n        const resNodes = [nodes[0]];\r\n        const pickFlags = [];\r\n        const n = nodes.length;\r\n        pickFlags[0] = true;\r\n        initHierarchy(cnodes, edges, nodeMap, directed);\r\n        let k = 0;\r\n        cnodes.forEach((cnode, i) => {\r\n            if (i !== 0) {\r\n                if ((i === n - 1 ||\r\n                    degrees[i] !== degrees[i + 1] ||\r\n                    connect(orderedCNodes[k], cnode, edges)) &&\r\n                    !pickFlags[i]) {\r\n                    orderedCNodes.push(cnode);\r\n                    resNodes.push(nodes[nodeMap[cnode.id]]);\r\n                    pickFlags[i] = true;\r\n                    k++;\r\n                }\r\n                else {\r\n                    const children = orderedCNodes[k].children;\r\n                    let foundChild = false;\r\n                    for (let j = 0; j < children.length; j++) {\r\n                        const childIdx = nodeMap[children[j]];\r\n                        if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\r\n                            orderedCNodes.push(cnodes[childIdx]);\r\n                            resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\r\n                            pickFlags[childIdx] = true;\r\n                            foundChild = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    let ii = 0;\r\n                    while (!foundChild) {\r\n                        if (!pickFlags[ii]) {\r\n                            orderedCNodes.push(cnodes[ii]);\r\n                            resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\r\n                            pickFlags[ii] = true;\r\n                            foundChild = true;\r\n                        }\r\n                        ii++;\r\n                        if (ii === n) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return resNodes;\r\n    }\r\n    /**\r\n     * 根据节点度数大小排序\r\n     * @return {array} orderedNodes 排序后的结果\r\n     */\r\n    degreeOrdering() {\r\n        const self = this;\r\n        const nodes = self.nodes;\r\n        const orderedNodes = [];\r\n        const degrees = self.degrees;\r\n        nodes.forEach((node, i) => {\r\n            node.degree = degrees[i];\r\n            orderedNodes.push(node);\r\n        });\r\n        orderedNodes.sort(compareDegree);\r\n        return orderedNodes;\r\n    }\r\n    getType() {\r\n        return \"circular\";\r\n    }\r\n}\r\n//# sourceMappingURL=circular.js.map"]},"metadata":{},"sourceType":"module"}