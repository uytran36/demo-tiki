{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { __spreadArray } from \"tslib\";\nimport floydWarshall from './floydWarshall';\nimport gSpan from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n/**\r\n * 为 graphData 中每个节点生成邻居单元数组\r\n * @param graphData\r\n * @param spm\r\n * @param nodeLabelProp\r\n * @param k k-近邻\r\n */\n\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (k === void 0) {\n    k = 2;\n  }\n\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\r\n * 随机寻找点对，满足距离小于 k\r\n * @param k 参数 k，表示 k-近邻\r\n * @param nodeNum 参数 length\r\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\r\n * @param spm 最短路径矩阵\r\n */\n\n\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n\n    var neighborNum = unit.neighborNum - 1;\n\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n\n      while (nodePairMap[i + \"-\" + oidx] || nodePairMap[oidx + \"-\" + i]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[i + \"-\" + oidx] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\n\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n\n\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\r\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\r\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\r\n * @param neighborUnits 每个节点的邻居元数组\r\n * @param graphData 原图数据\r\n * @param edgeMap 边的 map，方便检索\r\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\r\n */\n\n\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n\n      intersectIdMap[node.id] = true;\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n\n\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\r\n * 计算 strcutre 在 graph 上的匹配数量\r\n * @param graph 图数据\r\n * @param structure 目前支持只有两个节点一条边的最简单结构\r\n * @param nodeLabelProp 节点类型字段名\r\n * @param edgeLabelProp 边类型字段名\r\n */\n\n\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\r\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\r\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\r\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\r\n * @param structures\r\n */\n\n\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n      representClusterType = 0;\n\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\n\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n\n    var aveIntraDist = 0; // 该类的类内平均值\n\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\n\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\n\n    var aveInterDist = 0; // 类间间距平均值\n\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n\n    var offset = aveInterDist - aveIntraDist;\n\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\n\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n      nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\n\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n      edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\" + uniqueId] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n    if (sourceNode) sourceNode.degree++;\n    var targetNode = nodeMap[edge.target];\n    if (targetNode) targetNode.degree++;\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\r\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\r\n * @param nodes\r\n * @param spm\r\n * @param directed\r\n */\n\n\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[iId + \"-\" + jId] = dist;\n      if (!directed) map[jId + \"-\" + iId] = dist;\n    }\n  });\n  return map;\n};\n/**\r\n * 计算一对节点（node1，node2）的 NDS 距离\r\n * @param graph 原图数据\r\n * @param node1\r\n * @param node2\r\n */\n\n\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n\n  var key = node1.id + \"-\" + node2.id;\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\n\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\r\n * GADDI 模式匹配\r\n * @param graphData 原图数据\r\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\r\n * @param directed 是否计算有向图，默认 false\r\n * @param k 参数 k，表示 k-近邻\r\n * @param length 参数 length\r\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\r\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\r\n */\n\n\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  if (!graphData || !graphData.nodes) return; // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n\n  var spm = floydWarshall(graphData, directed); // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n\n  var patternSpm = floydWarshall(pattern, directed); // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n\n  var _a = getNodeMaps(graphData.nodes, nodeLabelProp),\n      nodeMap = _a.nodeMap,\n      nodeLabelMap = _a.nodeLabelMap;\n\n  var _b = getNodeMaps(pattern.nodes, nodeLabelProp),\n      patternNodeMap = _b.nodeMap,\n      patternNodeLabelMap = _b.nodeLabelMap; // 计算节点度数\n\n\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n\n  if (!length) length = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpm[0]), [2]));\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, patternKNeighborUnits, spm); // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n\n  var top = 10,\n      minSupport = 1,\n      minNodeNum = 1,\n      maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  }; // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n\n  var freStructures = gSpan(params).slice(0, top); // structureNum 可能小于 top\n\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  }); // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n\n  var _c = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n      dsG = _c.structure,\n      ndsDist = _c.structureCountMap; // -------- 第二步，匹配-------\n  // 2.1 从 Q 中的第一个标签的第一个节点开始，寻找 G 中的匹配\n\n\n  var beginPNode = pattern.nodes[0];\n  var label = beginPNode[nodeLabelProp]; // 2.1.1 找到 G 中标签与之相同的节点\n\n  var candidates = nodeLabelMap[label]; // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n\n  var patternIntGraphMap = {},\n      patternNDSDist = {},\n      // key 为 node.id-node.id\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n\n  var patternSpDist = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[beginPNode.id + \"-\" + nodeWithLabel2.id];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[beginPNode.id + \"-\" + nodeWithLabel2.id] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n    }); // spDist[label2] 按照从小到大排序\n\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\n\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[beginPNode.id + \"-\" + label2] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = candidates.length;\n\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n\n\n      var prune2Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n\n\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[cNode.id + \"-\" + neighborNode.id];\n        cNodePairMap[cNode.id + \"-\" + neighborNode.id] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      }); // 更新 intGMap\n\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      }); // 根据值为 currentNDSDistArray 从大到小排序\n\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = []; // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n\n  candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\n\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n\n    var _loop_5 = function _loop_5(i) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return {\n          value: void 0\n        };\n      }\n\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      }\n\n      var key = candidate.id + \"-\" + neighborNode.id; // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune2.2\n\n\n      var distToCandidate = spmMap[key];\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n\n\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = beginPNode.id + \"-\" + neighborLabel;\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n\n\n      var minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\n\n      if (minPatternNodeLabelDegree === undefined) {\n        minPatternNodeLabelDegree = Infinity;\n        patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n          if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n        });\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\n      }\n\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      var state_2 = _loop_5(i);\n\n      if (_typeof(state_2) === \"object\") return state_2.value;\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n\n\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  }); // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  var undirectedLengthsToBeginPNode = dijkstra(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\n\n\n  var candidateGraphNum = candidateGraphs.length;\n\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n      }\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // 遍历 candidateEdges，进行边的筛选\n\n\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\n\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n\n    var candidateGraphInvalid = false;\n\n    var _loop_6 = function _loop_6(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        return \"continue\";\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n\n\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        return \"continue\";\n      }\n    };\n\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_3 = _loop_6(e);\n\n      if (state_3 === \"break\") break;\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = dijkstra(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n\n\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    var degreeChanged = true;\n    var loopCount = 0;\n\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false; // candidate 度数不足，删去该图\n\n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\n        candidateGraphInvalid = true;\n        break;\n      } // candidate label 个数不足，删去该图\n\n\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      } // prune6：去除度数过小的节点\n\n\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\n\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n\n      candidateEdgeNum = candidateEdges.length;\n\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--; // 边 label 数量不足\n\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          degreeChanged = true;\n        }\n      }\n\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n\n\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n\n    if (state_1 === \"break\") break;\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n\n\n  var currentLength = candidateGraphs.length;\n\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n    cg1.edges.forEach(function (edge) {\n      var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n\n    var _loop_7 = function _loop_7(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n      cg2.edges.forEach(function (edge) {\n        var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_7(j);\n    }\n\n    currentLength = candidateGraphs.length;\n  };\n\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;","map":{"version":3,"sources":["D:/SQL/sqlindex2/sql/frontend/node_modules/@antv/algorithm/es/gaddi.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","__spreadArray","floydWarshall","gSpan","dijkstra","uniqueId","findKNeighborUnits","graphData","spm","nodeLabelProp","k","units","nodes","forEach","row","i","push","findKNeighborUnit","unitNodeIdxs","neighbors","labelCountMap","v","j","label","count","dists","Object","keys","sort","a","b","nodeIdx","nodeId","id","nodeIdxs","neighborNum","length","nodeLabelCountMap","findNodePairsRandomly","nodeNum","maxNodePairNum","kNeighborUnits","nodePairNumEachNode","Math","ceil","nodePairMap","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","floor","random","innerLoopCount","start","end","distance","gap","getIntersectNeighborInducedGraph","neighborUnits","cachedInducedGraphMap","key","_a","_b","edges","pair","startUnitNodeIds","endUnitNodeIds","endSet","Set","intersect","filter","x","has","intersectIdMap","intersectLength","node","edge","source","target","getMatchedCount","graph","structure","edgeLabelProp","nodeMap","e","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","findRepresentStructure","matchedCountMap","structureNum","structures","maxOffset","Infinity","representClusterType","_loop_1","countMapI","sortedGraphKeys","groupNum","clusters","graphs","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","abs","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","getNodeMaps","nodeLabelMap","idx","degree","getEdgeMaps","edgeMap","edgeLabelMap","sourceNode","targetNode","getSpmMap","directed","map","iId","jId","dist","getNDSDist","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","undefined","pairMap","GADDI","pattern","patternSpm","spmMap","patternSpmMap","patternNodeMap","patternNodeLabelMap","patternEdgeLabelMap","max","apply","patternKNeighborUnits","min","nodePairsMap","intGMap","top","minSupport","minNodeNum","maxNodeNum","params","freStructures","slice","subStructureCount","_c","dsG","ndsDist","beginPNode","candidates","minPatternNodeLabelDegreeMap","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","currentPatternNDSDistArray","patternIntGraph","candidatesNum","_loop_4","m","cNode","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","splice","prune2Invalid","n","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","lengthNeighborUnit","neighborNodes","unmatched","_loop_5","value","neighborLabel","distToCandidate","maxDistWithLabelInPattern","ndsToCandidate","patternKey","minNdsWithLabelInPattern","minPatternNodeLabelDegree","patternNodeWithLabel","patternNodeDegree","state_2","concat","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","nodeLabel","pLabel","candidateGraphNum","_loop_2","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","label_1","candidateEdgeNum","candidateGraphInvalid","_loop_6","edgeLabel","patternEdgesWithLabel","edgeMatched","patternEdge","patternSource","patternTarget","state_3","lengthsToCandidate","reverse","targetId","targetNodeLabel","indexOf","nLabel","degreeChanged","loopCount","currentCandidateNodeNum","o","cgNode","nodeDegree","y","cedge","state_1","currentLength","_loop_3","cg1","cg1EdgeMap","_loop_7","cg2","cg2EdgeMap","same"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nimport { __spreadArray } from \"tslib\";\r\nimport floydWarshall from './floydWarshall';\r\nimport gSpan from './gSpan/gSpan';\r\nimport dijkstra from './dijkstra';\r\nimport { uniqueId } from './util';\r\n/**\r\n * 为 graphData 中每个节点生成邻居单元数组\r\n * @param graphData\r\n * @param spm\r\n * @param nodeLabelProp\r\n * @param k k-近邻\r\n */\r\n\r\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\r\n  if (nodeLabelProp === void 0) {\r\n    nodeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (k === void 0) {\r\n    k = 2;\r\n  }\r\n\r\n  var units = [];\r\n  var nodes = graphData.nodes;\r\n  spm.forEach(function (row, i) {\r\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\r\n  });\r\n  return units;\r\n};\r\n\r\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\r\n  var unitNodeIdxs = [i];\r\n  var neighbors = [];\r\n  var labelCountMap = {};\r\n  row.forEach(function (v, j) {\r\n    if (v <= k && i !== j) {\r\n      unitNodeIdxs.push(j);\r\n      neighbors.push(nodes[j]);\r\n      var label = nodes[j][nodeLabelProp];\r\n      if (!labelCountMap[label]) labelCountMap[label] = {\r\n        count: 1,\r\n        dists: [v]\r\n      };else {\r\n        labelCountMap[label].count++;\r\n        labelCountMap[label].dists.push(v);\r\n      }\r\n    }\r\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\r\n\r\n  Object.keys(labelCountMap).forEach(function (label) {\r\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\r\n      return a - b;\r\n    });\r\n  });\r\n  return {\r\n    nodeIdx: i,\r\n    nodeId: nodes[i].id,\r\n    nodeIdxs: unitNodeIdxs,\r\n    neighbors: neighbors,\r\n    neighborNum: unitNodeIdxs.length - 1,\r\n    nodeLabelCountMap: labelCountMap\r\n  };\r\n};\r\n/**\r\n * 随机寻找点对，满足距离小于 k\r\n * @param k 参数 k，表示 k-近邻\r\n * @param nodeNum 参数 length\r\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\r\n * @param spm 最短路径矩阵\r\n */\r\n\r\n\r\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\r\n  // 每个节点需要随机找出的点对数\r\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\r\n  var nodePairMap = {};\r\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\r\n\r\n  kNeighborUnits.forEach(function (unit, i) {\r\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\r\n    var nodePairForICount = 0;\r\n    var outerLoopCount = 0;\r\n    var neighbors = unit.nodeIdxs; // the first one is the center node\r\n\r\n    var neighborNum = unit.neighborNum - 1;\r\n\r\n    while (nodePairForICount < nodePairNumEachNode) {\r\n      // 另一端节点在节点数组中的的 index\r\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\r\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\r\n\r\n      while (nodePairMap[i + \"-\" + oidx] || nodePairMap[oidx + \"-\" + i]) {\r\n        oidx = Math.floor(Math.random() * nodeNum);\r\n        innerLoopCount++;\r\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\r\n      }\r\n\r\n      if (innerLoopCount < 2 * nodeNum) {\r\n        // 未达到最大循环次数，说明找到了合适的另一端\r\n        nodePairMap[i + \"-\" + oidx] = {\r\n          start: i,\r\n          end: oidx,\r\n          distance: spm[i][oidx]\r\n        };\r\n        nodePairForICount++;\r\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\r\n\r\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\r\n      }\r\n\r\n      outerLoopCount++;\r\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\r\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\r\n\r\n\r\n    if (nodePairForICount < nodePairNumEachNode) {\r\n      var gap = nodePairNumEachNode - nodePairForICount;\r\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\r\n    }\r\n  });\r\n  return nodePairMap;\r\n};\r\n/**\r\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\r\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\r\n * @param neighborUnits 每个节点的邻居元数组\r\n * @param graphData 原图数据\r\n * @param edgeMap 边的 map，方便检索\r\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\r\n */\r\n\r\n\r\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\r\n  var nodes = graphData.nodes;\r\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\r\n  Object.keys(nodePairMap).forEach(function (key) {\r\n    var _a, _b;\r\n\r\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\r\n    cachedInducedGraphMap[key] = {\r\n      nodes: [],\r\n      edges: []\r\n    };\r\n    var pair = nodePairMap[key];\r\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\r\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\r\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\r\n\r\n    var endSet = new Set(endUnitNodeIds);\r\n    var intersect = startUnitNodeIds.filter(function (x) {\r\n      return endSet.has(x);\r\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\r\n\r\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\r\n\r\n    var intersectIdMap = {};\r\n    var intersectLength = intersect.length;\r\n\r\n    for (var i = 0; i < intersectLength; i++) {\r\n      var node = nodes[intersect[i]];\r\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\r\n\r\n      intersectIdMap[node.id] = true;\r\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\r\n\r\n\r\n    graphData.edges.forEach(function (edge) {\r\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\r\n    });\r\n  });\r\n  return cachedInducedGraphMap;\r\n};\r\n/**\r\n * 计算 strcutre 在 graph 上的匹配数量\r\n * @param graph 图数据\r\n * @param structure 目前支持只有两个节点一条边的最简单结构\r\n * @param nodeLabelProp 节点类型字段名\r\n * @param edgeLabelProp 边类型字段名\r\n */\r\n\r\n\r\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\r\n  var nodeMap = {};\r\n  graph.nodes.forEach(function (node) {\r\n    nodeMap[node.id] = node;\r\n  });\r\n  var count = 0;\r\n  graph.edges.forEach(function (e) {\r\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\r\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\r\n    var strNodeLabel1 = structure.nodes[0][nodeLabelProp];\r\n    var strNodeLabel2 = structure.nodes[1][nodeLabelProp];\r\n    var strEdgeLabel = structure.edges[0][edgeLabelProp];\r\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\r\n\r\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\r\n      count++;\r\n    }\r\n  });\r\n  return count;\r\n};\r\n/**\r\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\r\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\r\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\r\n * @param structures\r\n */\r\n\r\n\r\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\r\n  var maxOffset = Infinity,\r\n      representClusterType = 0;\r\n\r\n  var _loop_1 = function _loop_1(i) {\r\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\r\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\r\n\r\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\r\n      return countMapI[a] - countMapI[b];\r\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\r\n\r\n    var groupNum = 10;\r\n    var clusters = []; // 总共有 groupNum 个项\r\n\r\n    sortedGraphKeys.forEach(function (key, j) {\r\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\r\n        graphs: [],\r\n        totalCount: 0,\r\n        aveCount: 0\r\n      };\r\n      clusters[j % groupNum].graphs.push(key);\r\n      clusters[j % groupNum].totalCount += countMapI[key];\r\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\r\n\r\n    var aveIntraDist = 0; // 该类的类内平均值\r\n\r\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\r\n\r\n    clusters.forEach(function (graphsInCluster) {\r\n      // 类内均值\r\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\r\n      graphsInCluster.aveCount = aveCount;\r\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\r\n\r\n      var aveIntraPerCluster = 0;\r\n      var graphsNum = graphsInCluster.length;\r\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\r\n        var graph1Count = countMapI[graphKey1];\r\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\r\n          if (j === k) return;\r\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\r\n        });\r\n      });\r\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\r\n      aveIntraDist += aveIntraPerCluster;\r\n    });\r\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\r\n\r\n    var aveInterDist = 0; // 类间间距平均值\r\n\r\n    aveCounts.forEach(function (aveCount1, j) {\r\n      aveCounts.forEach(function (aveCount2, k) {\r\n        if (j === k) return;\r\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\r\n      });\r\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\r\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\r\n\r\n    var offset = aveInterDist - aveIntraDist;\r\n\r\n    if (maxOffset < offset) {\r\n      maxOffset = offset;\r\n      representClusterType = i;\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < structureNum; i++) {\r\n    _loop_1(i);\r\n  }\r\n\r\n  return {\r\n    structure: structures[representClusterType],\r\n    structureCountMap: matchedCountMap[representClusterType]\r\n  };\r\n};\r\n\r\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\r\n  var nodeMap = {},\r\n      nodeLabelMap = {};\r\n  nodes.forEach(function (node, i) {\r\n    nodeMap[node.id] = {\r\n      idx: i,\r\n      node: node,\r\n      degree: 0\r\n    };\r\n    var label = node[nodeLabelProp];\r\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\r\n    nodeLabelMap[label].push(node);\r\n  });\r\n  return {\r\n    nodeMap: nodeMap,\r\n    nodeLabelMap: nodeLabelMap\r\n  };\r\n};\r\n\r\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\r\n  var edgeMap = {},\r\n      edgeLabelMap = {};\r\n  edges.forEach(function (edge, i) {\r\n    edgeMap[\"\" + uniqueId] = {\r\n      idx: i,\r\n      edge: edge\r\n    };\r\n    var label = edge[edgeLabelProp];\r\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\r\n    edgeLabelMap[label].push(edge);\r\n    var sourceNode = nodeMap[edge.source];\r\n    if (sourceNode) sourceNode.degree++;\r\n    var targetNode = nodeMap[edge.target];\r\n    if (targetNode) targetNode.degree++;\r\n  });\r\n  return {\r\n    edgeMap: edgeMap,\r\n    edgeLabelMap: edgeLabelMap\r\n  };\r\n};\r\n/**\r\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\r\n * @param nodes\r\n * @param spm\r\n * @param directed\r\n */\r\n\r\n\r\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\r\n  var length = spm.length;\r\n  var map = {};\r\n  spm.forEach(function (row, i) {\r\n    var start = directed ? 0 : i + 1;\r\n    var iId = nodes[i].id;\r\n\r\n    for (var j = start; j < length; j++) {\r\n      if (i === j) continue;\r\n      var jId = nodes[j].id;\r\n      var dist = row[j];\r\n      map[iId + \"-\" + jId] = dist;\r\n      if (!directed) map[jId + \"-\" + iId] = dist;\r\n    }\r\n  });\r\n  return map;\r\n};\r\n/**\r\n * 计算一对节点（node1，node2）的 NDS 距离\r\n * @param graph 原图数据\r\n * @param node1\r\n * @param node2\r\n */\r\n\r\n\r\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\r\n  var _a;\r\n\r\n  var key = node1.id + \"-\" + node2.id;\r\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\r\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\r\n\r\n  if (!interInducedGraph) {\r\n    var pairMap = (_a = {}, _a[key] = {\r\n      start: nodeMap[node1.id].idx,\r\n      end: nodeMap[node2.id].idx,\r\n      distance: spDist\r\n    }, _a);\r\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\r\n    interInducedGraph = cachedInterInducedGraph[key];\r\n  }\r\n\r\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\r\n};\r\n/**\r\n * GADDI 模式匹配\r\n * @param graphData 原图数据\r\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\r\n * @param directed 是否计算有向图，默认 false\r\n * @param k 参数 k，表示 k-近邻\r\n * @param length 参数 length\r\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\r\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\r\n */\r\n\r\n\r\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (nodeLabelProp === void 0) {\r\n    nodeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (edgeLabelProp === void 0) {\r\n    edgeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (!graphData || !graphData.nodes) return; // 分为三步：\r\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\r\n  // 1. 处理原图 graphData。再分为 1~5 小步\r\n  // 2. 匹配\r\n  // console.log(\"----- stage-pre: preprocessing -------\");\r\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\r\n\r\n  var nodeNum = graphData.nodes.length;\r\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\r\n\r\n  var spm = floydWarshall(graphData, directed); // console.log(\r\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\r\n  // );\r\n\r\n  var patternSpm = floydWarshall(pattern, directed); // console.log(\r\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\r\n  // );\r\n\r\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\r\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\r\n  // );\r\n\r\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\r\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\r\n\r\n  var _a = getNodeMaps(graphData.nodes, nodeLabelProp),\r\n      nodeMap = _a.nodeMap,\r\n      nodeLabelMap = _a.nodeLabelMap;\r\n\r\n  var _b = getNodeMaps(pattern.nodes, nodeLabelProp),\r\n      patternNodeMap = _b.nodeMap,\r\n      patternNodeLabelMap = _b.nodeLabelMap; // 计算节点度数\r\n\r\n\r\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\r\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\r\n\r\n  if (!length) length = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpm[0]), [2]));\r\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\r\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\r\n  // 计算每个节点的 k 邻元集合\r\n\r\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\r\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\r\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\r\n  // );\r\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\r\n  // -------- 第一步，处理原图 graphData-------\r\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\r\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\r\n\r\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\r\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, patternKNeighborUnits, spm); // console.log(\r\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\r\n  // );\r\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\r\n\r\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\r\n\r\n  var top = 10,\r\n      minSupport = 1,\r\n      minNodeNum = 1,\r\n      maxNodeNum = 4;\r\n  var params = {\r\n    graphs: intGMap,\r\n    nodeLabelProp: nodeLabelProp,\r\n    edgeLabelProp: edgeLabelProp,\r\n    minSupport: minSupport,\r\n    minNodeNum: minNodeNum,\r\n    maxNodeNum: maxNodeNum,\r\n    directed: directed\r\n  }; // console.log(\r\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\r\n  // );\r\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\r\n  // 暂时假设生成的 sub structure 都只有一条边\r\n\r\n  var freStructures = gSpan(params).slice(0, top); // structureNum 可能小于 top\r\n\r\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\r\n\r\n  var matchedCountMap = [];\r\n  freStructures.forEach(function (structure, i) {\r\n    matchedCountMap[i] = {};\r\n    Object.keys(intGMap).forEach(function (key) {\r\n      var graph = intGMap[key];\r\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\r\n      matchedCountMap[i][key] = subStructureCount;\r\n    });\r\n  }); // console.log(\r\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\r\n  // );\r\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\r\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\r\n\r\n  var _c = findRepresentStructure(matchedCountMap, structureNum, freStructures),\r\n      dsG = _c.structure,\r\n      ndsDist = _c.structureCountMap; // -------- 第二步，匹配-------\r\n  // 2.1 从 Q 中的第一个标签的第一个节点开始，寻找 G 中的匹配\r\n\r\n\r\n  var beginPNode = pattern.nodes[0];\r\n  var label = beginPNode[nodeLabelProp]; // 2.1.1 找到 G 中标签与之相同的节点\r\n\r\n  var candidates = nodeLabelMap[label]; // console.log(\"----- stage2: going to find candidates -------\");\r\n  // 全局缓存，避免重复计算\r\n\r\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\r\n\r\n  var patternIntGraphMap = {},\r\n      patternNDSDist = {},\r\n      // key 为 node.id-node.id\r\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\r\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\r\n\r\n  var patternSpDist = {};\r\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\r\n    patternSpDist[label2] = [];\r\n    var maxDist = -Infinity;\r\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\r\n    var patternNodePairMap = {};\r\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\r\n      var dist = patternSpmMap[beginPNode.id + \"-\" + nodeWithLabel2.id];\r\n      dist && patternSpDist[label2].push(dist);\r\n      if (maxDist < dist) maxDist = dist;\r\n      patternNodePairMap[beginPNode.id + \"-\" + nodeWithLabel2.id] = {\r\n        start: 0,\r\n        end: patternNodeMap[nodeWithLabel2.id].idx,\r\n        distance: dist\r\n      };\r\n    }); // spDist[label2] 按照从小到大排序\r\n\r\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\r\n      return a - b;\r\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\r\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\r\n    // key: node1.id-node2.id\r\n\r\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\r\n\r\n    var currentPatternNDSDistArray = [];\r\n    Object.keys(patternNodePairMap).forEach(function (key) {\r\n      if (patternNDSDist[key]) {\r\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\r\n        return; // 缓存过则不需要再次计算\r\n      }\r\n\r\n      var patternIntGraph = patternIntGraphMap[key];\r\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\r\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\r\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\r\n\r\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\r\n      return b - a;\r\n    });\r\n    patternNDSDistMap[beginPNode.id + \"-\" + label2] = currentPatternNDSDistArray;\r\n    if (label2 === label) return;\r\n    var candidatesNum = candidates.length;\r\n\r\n    var _loop_4 = function _loop_4(m) {\r\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\r\n\r\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\r\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\r\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\r\n\r\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\r\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\r\n\r\n\r\n      var prune2Invalid = false;\r\n\r\n      for (var n = 0; n < patternLabel2Num; n++) {\r\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\r\n          prune2Invalid = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (prune2Invalid) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\r\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\r\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\r\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\r\n\r\n\r\n      var cNodePairMap = {};\r\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\r\n        var dist = spmMap[cNode.id + \"-\" + neighborNode.id];\r\n        cNodePairMap[cNode.id + \"-\" + neighborNode.id] = {\r\n          start: nodeMap[cNode.id].idx,\r\n          end: nodeMap[neighborNode.id].idx,\r\n          distance: dist\r\n        };\r\n      }); // 更新 intGMap\r\n\r\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\r\n\r\n      var currentNDSDistArray = [];\r\n      Object.keys(cNodePairMap).forEach(function (key) {\r\n        if (ndsDist[key]) {\r\n          currentNDSDistArray.push(ndsDist[key]);\r\n          return; // 缓存过则不需要再次计算\r\n        }\r\n\r\n        var intGraph = intGMap[key];\r\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\r\n        currentNDSDistArray.push(ndsDist[key]);\r\n      }); // 根据值为 currentNDSDistArray 从大到小排序\r\n\r\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\r\n        return b - a;\r\n      });\r\n      var prune3Invalid = false;\r\n\r\n      for (var n = 0; n < patternLabel2Num; n++) {\r\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\r\n          prune3Invalid = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (prune3Invalid) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      }\r\n    };\r\n\r\n    for (var m = candidatesNum - 1; m >= 0; m--) {\r\n      _loop_4(m);\r\n    }\r\n  });\r\n  var candidateGraphs = []; // console.log(\r\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\r\n  // );\r\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\r\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\r\n\r\n  candidates.forEach(function (candidate) {\r\n    var nodeIdx = nodeMap[candidate.id].idx;\r\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\r\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\r\n\r\n    var neighborNum = neighborNodes.length;\r\n    var unmatched = false;\r\n\r\n    var _loop_5 = function _loop_5(i) {\r\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\r\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\r\n        unmatched = true;\r\n        return {\r\n          value: void 0\r\n        };\r\n      }\r\n\r\n      var neighborNode = neighborNodes[i];\r\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\r\n\r\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\r\n        neighborNodes.splice(i, 1);\r\n        return \"continue\";\r\n      }\r\n\r\n      var key = candidate.id + \"-\" + neighborNode.id; // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\r\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\r\n\r\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\r\n        neighborNodes.splice(i, 1);\r\n        return \"continue\";\r\n      } // prune2.2\r\n\r\n\r\n      var distToCandidate = spmMap[key];\r\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] 已经按照从小到大排序\r\n\r\n      if (distToCandidate > maxDistWithLabelInPattern) {\r\n        neighborNodes.splice(i, 1);\r\n        return \"continue\";\r\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\r\n\r\n\r\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\r\n      var patternKey = beginPNode.id + \"-\" + neighborLabel;\r\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\r\n\r\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\r\n        neighborNodes.splice(i, 1);\r\n        return \"continue\";\r\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\r\n\r\n\r\n      var minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\r\n\r\n      if (minPatternNodeLabelDegree === undefined) {\r\n        minPatternNodeLabelDegree = Infinity;\r\n        patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\r\n          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\r\n          if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\r\n        });\r\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\r\n      }\r\n\r\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\r\n        neighborNodes.splice(i, 1);\r\n        return \"continue\";\r\n      }\r\n    };\r\n\r\n    for (var i = neighborNum - 1; i >= 0; i--) {\r\n      var state_2 = _loop_5(i);\r\n\r\n      if (_typeof(state_2) === \"object\") return state_2.value;\r\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\r\n\r\n\r\n    if (!unmatched) {\r\n      candidateGraphs.push({\r\n        nodes: [candidate].concat(neighborNodes)\r\n      });\r\n    }\r\n  }); // console.log(\r\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\r\n  // );\r\n\r\n  var undirectedLengthsToBeginPNode = dijkstra(pattern, beginPNode.id, false).length;\r\n  var undirectedLengthsToBeginPNodeLabelMap = {};\r\n\r\n  if (directed) {\r\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\r\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\r\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\r\n    });\r\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\r\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\r\n        return a - b;\r\n      });\r\n    });\r\n  } else {\r\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\r\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\r\n\r\n\r\n  var candidateGraphNum = candidateGraphs.length;\r\n\r\n  var _loop_2 = function _loop_2(i) {\r\n    var candidateGraph = candidateGraphs[i];\r\n    var candidate = candidateGraph.nodes[0];\r\n    var candidateNodeLabelCountMap = {};\r\n    var candidateNodeMap = {};\r\n    candidateGraph.nodes.forEach(function (node, q) {\r\n      candidateNodeMap[node.id] = {\r\n        idx: q,\r\n        node: node,\r\n        degree: 0\r\n      };\r\n      var cNodeLabel = node[nodeLabelProp];\r\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\r\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\r\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\r\n\r\n    var candidateEdges = [];\r\n    var edgeLabelCountMap = {};\r\n    graphData.edges.forEach(function (edge) {\r\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\r\n        candidateEdges.push(edge);\r\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\r\n        candidateNodeMap[edge.source].degree++;\r\n        candidateNodeMap[edge.target].degree++;\r\n      }\r\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\r\n\r\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\r\n    var prunedByEdgeLabel = false;\r\n\r\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\r\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\r\n\r\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\r\n        prunedByEdgeLabel = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (prunedByEdgeLabel) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    } // 遍历 candidateEdges，进行边的筛选\r\n\r\n\r\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\r\n\r\n    if (candidateEdgeNum < pattern.edges.length) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"break\";\r\n    }\r\n\r\n    var candidateGraphInvalid = false;\r\n\r\n    var _loop_6 = function _loop_6(e) {\r\n      var edge = candidateEdges[e];\r\n      var edgeLabel = edge[edgeLabelProp];\r\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\r\n\r\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\r\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\r\n\r\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\r\n          candidateGraphInvalid = true;\r\n          return \"break\";\r\n        }\r\n\r\n        candidateEdges.splice(e, 1);\r\n        candidateNodeMap[edge.source].degree--;\r\n        candidateNodeMap[edge.target].degree--;\r\n        return \"continue\";\r\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\r\n\r\n\r\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\r\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\r\n      var edgeMatched = false;\r\n      patternEdgesWithLabel.forEach(function (patternEdge) {\r\n        var patternSource = patternNodeMap[patternEdge.source].node;\r\n        var patternTarget = patternNodeMap[patternEdge.target].node;\r\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\r\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\r\n      });\r\n\r\n      if (!edgeMatched) {\r\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\r\n\r\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\r\n          candidateGraphInvalid = true;\r\n          return \"break\";\r\n        }\r\n\r\n        candidateEdges.splice(e, 1);\r\n        candidateNodeMap[edge.source].degree--;\r\n        candidateNodeMap[edge.target].degree--;\r\n        return \"continue\";\r\n      }\r\n    };\r\n\r\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\r\n      var state_3 = _loop_6(e);\r\n\r\n      if (state_3 === \"break\") break;\r\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\r\n\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n\r\n    candidateGraph.edges = candidateEdges;\r\n    var lengthsToCandidate = dijkstra(candidateGraph, candidateGraph.nodes[0].id, false).length;\r\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\r\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\r\n\r\n      if (lengthsToCandidate[targetId] === Infinity) {\r\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\r\n        candidateNodeLabelCountMap[targetNodeLabel]--;\r\n\r\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\r\n          candidateGraphInvalid = true;\r\n          return;\r\n        }\r\n\r\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\r\n        candidateGraph.nodes.splice(idx, 1);\r\n        candidateNodeMap[targetId] = undefined;\r\n        return;\r\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\r\n\r\n\r\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\r\n\r\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\r\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\r\n        candidateNodeLabelCountMap[targetNodeLabel]--;\r\n\r\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\r\n          candidateGraphInvalid = true;\r\n          return;\r\n        }\r\n\r\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\r\n        candidateGraph.nodes.splice(idx, 1);\r\n        candidateNodeMap[targetId] = undefined;\r\n      }\r\n    });\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n\r\n    var degreeChanged = true;\r\n    var loopCount = 0;\r\n\r\n    while (degreeChanged && !candidateGraphInvalid) {\r\n      degreeChanged = false; // candidate 度数不足，删去该图\r\n\r\n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\r\n        candidateGraphInvalid = true;\r\n        break;\r\n      } // candidate label 个数不足，删去该图\r\n\r\n\r\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\r\n        candidateGraphInvalid = true;\r\n        break;\r\n      } // prune6：去除度数过小的节点\r\n\r\n\r\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\r\n\r\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\r\n        var cgNode = candidateGraph.nodes[o];\r\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\r\n        var cNodeLabel = cgNode[nodeLabelProp];\r\n\r\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\r\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\r\n\r\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\r\n            candidateGraphInvalid = true;\r\n            break;\r\n          }\r\n\r\n          candidateGraph.nodes.splice(o, 1);\r\n          candidateNodeMap[cgNode.id] = undefined;\r\n          degreeChanged = true;\r\n        }\r\n      }\r\n\r\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\r\n\r\n      candidateEdgeNum = candidateEdges.length;\r\n\r\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\r\n        var cedge = candidateEdges[y];\r\n\r\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\r\n          candidateEdges.splice(y, 1);\r\n          var edgeLabel = cedge[edgeLabelProp];\r\n          edgeLabelCountMap[edgeLabel]--;\r\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\r\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--; // 边 label 数量不足\r\n\r\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\r\n            candidateGraphInvalid = true;\r\n            break;\r\n          }\r\n\r\n          degreeChanged = true;\r\n        }\r\n      }\r\n\r\n      loopCount++;\r\n    }\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\r\n\r\n\r\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n  };\r\n\r\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\r\n    var state_1 = _loop_2(i);\r\n\r\n    if (state_1 === \"break\") break;\r\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\r\n  // console.log(\r\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\r\n  // );\r\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\r\n\r\n\r\n  var currentLength = candidateGraphs.length;\r\n\r\n  var _loop_3 = function _loop_3(i) {\r\n    var cg1 = candidateGraphs[i];\r\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\r\n\r\n    cg1.edges.forEach(function (edge) {\r\n      var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\r\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\r\n    });\r\n\r\n    var _loop_7 = function _loop_7(j) {\r\n      var cg2 = candidateGraphs[j];\r\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\r\n\r\n      cg2.edges.forEach(function (edge) {\r\n        var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\r\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\r\n      });\r\n      var same = true;\r\n\r\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\r\n        same = false;\r\n      } else {\r\n        Object.keys(cg1EdgeMap).forEach(function (key) {\r\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\r\n        });\r\n      }\r\n\r\n      if (same) {\r\n        candidateGraphs.splice(j, 1);\r\n      }\r\n    };\r\n\r\n    for (var j = currentLength - 1; j > i; j--) {\r\n      _loop_7(j);\r\n    }\r\n\r\n    currentLength = candidateGraphs.length;\r\n  };\r\n\r\n  for (var i = 0; i <= currentLength - 1; i++) {\r\n    _loop_3(i);\r\n  }\r\n\r\n  return candidateGraphs;\r\n};\r\n\r\nexport default GADDI;"]},"metadata":{},"sourceType":"module"}