{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport AxisBase from './base';\n\nvar Circle =\n/** @class */\nfunction (_super) {\n  __extends(Circle, _super);\n\n  function Circle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Circle.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: null,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n\n  Circle.prototype.getLinePath = function () {\n    var center = this.get('center');\n    var x = center.x;\n    var y = center.y;\n    var rx = this.get('radius');\n    var ry = rx;\n    var startAngle = this.get('startAngle');\n    var endAngle = this.get('endAngle');\n    var path = [];\n\n    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n      path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];\n    } else {\n      var startPoint = this.getCirclePoint(startAngle);\n      var endPoint = this.getCirclePoint(endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];\n    }\n\n    return path;\n  };\n\n  Circle.prototype.getTickPoint = function (tickValue) {\n    var startAngle = this.get('startAngle');\n    var endAngle = this.get('endAngle');\n    var angle = startAngle + (endAngle - startAngle) * tickValue;\n    return this.getCirclePoint(angle);\n  }; // 获取垂直于坐标轴的向量\n\n\n  Circle.prototype.getSideVector = function (offset, point) {\n    var center = this.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n    var factor = this.get('verticalFactor');\n    var vecLen = vec2.length(vector);\n    vec2.scale(vector, vector, factor * offset / vecLen);\n    return vector;\n  }; // 获取沿坐标轴方向的向量\n\n\n  Circle.prototype.getAxisVector = function (point) {\n    var center = this.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n    return [vector[1], -1 * vector[0]]; // 获取顺时针方向的向量\n  }; // 根据圆心和半径获取点\n\n\n  Circle.prototype.getCirclePoint = function (angle, radius) {\n    var center = this.get('center');\n    radius = radius || this.get('radius');\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  return Circle;\n}(AxisBase);\n\nexport default Circle;","map":{"version":3,"sources":["../../src/axis/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport { vec2 } from '@antv/matrix-util';\r\nimport AxisBase from './base';\r\nvar Circle = /** @class */ (function (_super) {\r\n    __extends(Circle, _super);\r\n    function Circle() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Circle.prototype.getDefaultCfg = function () {\r\n        var cfg = _super.prototype.getDefaultCfg.call(this);\r\n        return __assign(__assign({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: null, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });\r\n    };\r\n    Circle.prototype.getLinePath = function () {\r\n        var center = this.get('center');\r\n        var x = center.x;\r\n        var y = center.y;\r\n        var rx = this.get('radius');\r\n        var ry = rx;\r\n        var startAngle = this.get('startAngle');\r\n        var endAngle = this.get('endAngle');\r\n        var path = [];\r\n        if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\r\n            path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];\r\n        }\r\n        else {\r\n            var startPoint = this.getCirclePoint(startAngle);\r\n            var endPoint = this.getCirclePoint(endAngle);\r\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\r\n            var sweep = startAngle > endAngle ? 0 : 1;\r\n            path = [\r\n                ['M', x, y],\r\n                ['L', startPoint.x, startPoint.y],\r\n                ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y],\r\n                ['L', x, y],\r\n            ];\r\n        }\r\n        return path;\r\n    };\r\n    Circle.prototype.getTickPoint = function (tickValue) {\r\n        var startAngle = this.get('startAngle');\r\n        var endAngle = this.get('endAngle');\r\n        var angle = startAngle + (endAngle - startAngle) * tickValue;\r\n        return this.getCirclePoint(angle);\r\n    };\r\n    // 获取垂直于坐标轴的向量\r\n    Circle.prototype.getSideVector = function (offset, point) {\r\n        var center = this.get('center');\r\n        var vector = [point.x - center.x, point.y - center.y];\r\n        var factor = this.get('verticalFactor');\r\n        var vecLen = vec2.length(vector);\r\n        vec2.scale(vector, vector, (factor * offset) / vecLen);\r\n        return vector;\r\n    };\r\n    // 获取沿坐标轴方向的向量\r\n    Circle.prototype.getAxisVector = function (point) {\r\n        var center = this.get('center');\r\n        var vector = [point.x - center.x, point.y - center.y];\r\n        return [vector[1], -1 * vector[0]]; // 获取顺时针方向的向量\r\n    };\r\n    // 根据圆心和半径获取点\r\n    Circle.prototype.getCirclePoint = function (angle, radius) {\r\n        var center = this.get('center');\r\n        radius = radius || this.get('radius');\r\n        return {\r\n            x: center.x + Math.cos(angle) * radius,\r\n            y: center.y + Math.sin(angle) * radius,\r\n        };\r\n    };\r\n    return Circle;\r\n}(AxisBase));\r\nexport default Circle;\r\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}