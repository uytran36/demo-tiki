{"ast":null,"code":"/**\r\n * @fileoverview 椭圆的一些计算，\r\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\r\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\r\n * @author dxq613@gmail.com\r\n */\nimport { distance, piMod } from './util';\n\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport default {\n  /**\r\n   * 包围盒计算\r\n   * @param {number} x  椭圆中心 x\r\n   * @param {number} y  椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @return {object} 包围盒\r\n   */\n  box: function (x, y, rx, ry) {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2\n    };\n  },\n\n  /**\r\n   * 计算周长，使用近似法\r\n   * @param {number} x  椭圆中心 x\r\n   * @param {number} y  椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @return {number} 椭圆周长\r\n   */\n  length: function (x, y, rx, ry) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n\n  /**\r\n   * 距离椭圆最近的点\r\n   * @param {number} x  椭圆中心 x\r\n   * @param {number} y  椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @param {number} x0  指定的点 x\r\n   * @param {number} y0  指定的点 y\r\n   * @return {object} 椭圆上距离指定点最近的点\r\n   */\n  nearestPoint: function (x, y, rx, ry, x0, y0) {\n    var a = rx;\n    var b = ry; // 假如椭圆半径为0则返回圆心\n\n    if (a === 0 || b === 0) {\n      return {\n        x: x,\n        y: y\n      };\n    } // 转换成 0， 0 为中心的椭圆计算\n\n\n    var relativeX = x0 - x;\n    var relativeY = y0 - y;\n    var px = Math.abs(relativeX);\n    var py = Math.abs(relativeY);\n    var squareA = a * a;\n    var squareB = b * b; // const angle0 = Math.atan2(relativeY, relativeX);\n\n    var t = Math.PI / 4;\n    var nearestX; // 椭圆上的任一点\n\n    var nearestY; // 迭代 4 次\n\n    for (var i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n      var rx1 = nearestX - ex;\n      var ry1 = nearestY - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry1, rx1);\n      var q = Math.hypot(qy, qx);\n      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY)\n    };\n  },\n\n  /**\r\n   * 点到椭圆最近的距离\r\n   * @param {number} x  椭圆中心 x\r\n   * @param {number} y  椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @param {number} x0  指定的点 x\r\n   * @param {number} y0  指定的点 y\r\n   * @return {number} 点到椭圆的距离\r\n   */\n  pointDistance: function (x, y, rx, ry, x0, y0) {\n    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n\n  /**\r\n   * 根据比例获取点\r\n   * @param {number} x 椭圆中心 x\r\n   * @param {number} y 椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @param {number} t 指定比例，x轴方向为 0\r\n   * @return {object} 点\r\n   */\n  pointAt: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle)\n    };\n  },\n\n  /**\r\n   * 根据比例计算切线角度\r\n   * @param {number} x 椭圆中心 x\r\n   * @param {number} y 椭圆中心 y\r\n   * @param {number} rx 椭圆 x 方向半径\r\n   * @param {number} ry 椭圆 y 方向半径\r\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\r\n   * @return {number} 角度，在 0 - 2PI 之间\r\n   */\n  tangentAngle: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n\n    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle)); // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n\n    return piMod(tangentAngle);\n  }\n};","map":{"version":3,"sources":["../src/ellipse.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAAS,QAAT,EAAmB,KAAnB,QAAgC,QAAhC;;AAGA,SAAS,QAAT,CAAkB,EAAlB,EAA8B,EAA9B,EAAwC;AACtC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,CAAb;AACA,SAAO,EAAE,GAAG,CAAL,GAAS,IAAT,GAAgB,IAAI,GAAG,CAAC,CAA/B;AACD;;AAED,eAAe;AACb;;;;;;;AAOG;AACH,EAAA,GAAG,EAAH,UAAI,CAAJ,EAAe,CAAf,EAA0B,EAA1B,EAAsC,EAAtC,EAAgD;AAC9C,WAAO;AACL,MAAA,CAAC,EAAE,CAAC,GAAG,EADF;AAEL,MAAA,CAAC,EAAE,CAAC,GAAG,EAFF;AAGL,MAAA,KAAK,EAAE,EAAE,GAAG,CAHP;AAIL,MAAA,MAAM,EAAE,EAAE,GAAG;AAJR,KAAP;AAMD,GAhBY;;AAiBb;;;;;;;AAOG;AACH,EAAA,MAAM,EAAN,UAAO,CAAP,EAAkB,CAAlB,EAA6B,EAA7B,EAAyC,EAAzC,EAAmD;AACjD,WAAO,IAAI,CAAC,EAAL,IAAW,KAAK,EAAE,GAAG,EAAV,IAAgB,IAAI,CAAC,IAAL,CAAU,CAAC,IAAI,EAAJ,GAAS,EAAV,KAAiB,EAAE,GAAG,IAAI,EAA1B,CAAV,CAA3B,CAAP;AACD,GA3BY;;AA4Bb;;;;;;;;;AASG;AACH,EAAA,YAAY,EAAZ,UAAa,CAAb,EAAwB,CAAxB,EAAmC,EAAnC,EAA+C,EAA/C,EAA2D,EAA3D,EAAuE,EAAvE,EAAiF;AAC/E,QAAM,CAAC,GAAG,EAAV;AACA,QAAM,CAAC,GAAG,EAAV,CAF+E,CAG/E;;AACA,QAAI,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAArB,EAAwB;AACtB,aAAO;AACL,QAAA,CAAC,EAAA,CADI;AAEL,QAAA,CAAC,EAAA;AAFI,OAAP;AAID,KAT8E,CAU/E;;;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,CAAvB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,CAAvB;AACA,QAAM,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAX;AACA,QAAM,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAX;AACA,QAAM,OAAO,GAAG,CAAC,GAAG,CAApB;AACA,QAAM,OAAO,GAAG,CAAC,GAAG,CAApB,CAhB+E,CAiB/E;;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,EAAL,GAAU,CAAlB;AACA,QAAI,QAAJ,CAnB+E,CAmBzD;;AACtB,QAAI,QAAJ,CApB+E,CAqB/E;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,MAAA,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,CAAf;AACA,MAAA,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,CAAf;AAEA,UAAM,EAAE,GAAI,CAAC,OAAO,GAAG,OAAX,IAAsB,IAAA,CAAA,GAAA,CAAA,IAAI,CAAC,GAAL,CAAS,CAAT,CAAA,EAAe,CAAf,CAAvB,GAA2C,CAAtD;AACA,UAAM,EAAE,GAAI,CAAC,OAAO,GAAG,OAAX,IAAsB,IAAA,CAAA,GAAA,CAAA,IAAI,CAAC,GAAL,CAAS,CAAT,CAAA,EAAe,CAAf,CAAvB,GAA2C,CAAtD;AACA,UAAM,GAAG,GAAG,QAAQ,GAAG,EAAvB;AACA,UAAM,GAAG,GAAG,QAAQ,GAAG,EAAvB;AAEA,UAAM,EAAE,GAAG,EAAE,GAAG,EAAhB;AACA,UAAM,EAAE,GAAG,EAAE,GAAG,EAAhB;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,EAAgB,GAAhB,CAAV;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,EAAX,EAAe,EAAf,CAAV;AAEA,UAAM,OAAO,GAAG,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,CAAC,GAAG,GAAG,EAAN,GAAW,GAAG,GAAG,EAAlB,KAAyB,CAAC,GAAG,CAA7B,CAAV,CAApB;AACA,UAAM,OAAO,GAAG,OAAO,GAAG,IAAI,CAAC,IAAL,CAAU,OAAO,GAAG,OAAV,GAAoB,QAAQ,GAAG,QAA/B,GAA0C,QAAQ,GAAG,QAA/D,CAA1B;AAEA,MAAA,CAAC,IAAI,OAAL;AACA,MAAA,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,EAAL,GAAU,CAAnB,EAAsB,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAtB,CAAJ;AACD;;AAED,WAAO;AACL,MAAA,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,QAAD,EAAW,SAAX,CADV;AAEL,MAAA,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,QAAD,EAAW,SAAX;AAFV,KAAP;AAID,GArFY;;AAsFb;;;;;;;;;AASG;AACH,EAAA,aAAa,EAAb,UAAc,CAAd,EAAyB,CAAzB,EAAoC,EAApC,EAAgD,EAAhD,EAA4D,EAA5D,EAAwE,EAAxE,EAAkF;AAChF,QAAM,YAAY,GAAG,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,EAAxB,EAA4B,EAA5B,EAAgC,EAAhC,EAAoC,EAApC,CAArB;AACA,WAAO,QAAQ,CAAC,YAAY,CAAC,CAAd,EAAiB,YAAY,CAAC,CAA9B,EAAiC,EAAjC,EAAqC,EAArC,CAAf;AACD,GAnGY;;AAoGb;;;;;;;;AAQG;AACH,EAAA,OAAO,EAAP,UAAQ,CAAR,EAAmB,CAAnB,EAA8B,EAA9B,EAA0C,EAA1C,EAAsD,CAAtD,EAA+D;AAC7D,QAAM,KAAK,GAAG,IAAI,IAAI,CAAC,EAAT,GAAc,CAA5B,CAD6D,CAC9B;;AAC/B,WAAO;AACL,MAAA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CADP;AAEL,MAAA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT;AAFP,KAAP;AAID,GAnHY;;AAoHb;;;;;;;;AAQG;AACH,EAAA,YAAY,EAAZ,UAAa,CAAb,EAAwB,CAAxB,EAAmC,EAAnC,EAA+C,EAA/C,EAA2D,CAA3D,EAAoE;AAClE,QAAM,KAAK,GAAG,IAAI,IAAI,CAAC,EAAT,GAAc,CAA5B,CADkE,CACnC;AAC/B;;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAhB,EAAiC,CAAC,EAAD,GAAM,IAAI,CAAC,GAAL,CAAS,KAAT,CAAvC,CAArB,CAHkE,CAIlE;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAO,KAAK,CAAC,YAAD,CAAZ;AACD;AAzIY,CAAf","sourceRoot":"","sourcesContent":["/**\r\n * @fileoverview 椭圆的一些计算，\r\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\r\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\r\n * @author dxq613@gmail.com\r\n */\r\nimport { distance, piMod } from './util';\r\nfunction copysign(v1, v2) {\r\n    var absv = Math.abs(v1);\r\n    return v2 > 0 ? absv : absv * -1;\r\n}\r\nexport default {\r\n    /**\r\n     * 包围盒计算\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @return {object} 包围盒\r\n     */\r\n    box: function (x, y, rx, ry) {\r\n        return {\r\n            x: x - rx,\r\n            y: y - ry,\r\n            width: rx * 2,\r\n            height: ry * 2,\r\n        };\r\n    },\r\n    /**\r\n     * 计算周长，使用近似法\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @return {number} 椭圆周长\r\n     */\r\n    length: function (x, y, rx, ry) {\r\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\r\n    },\r\n    /**\r\n     * 距离椭圆最近的点\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} x0  指定的点 x\r\n     * @param {number} y0  指定的点 y\r\n     * @return {object} 椭圆上距离指定点最近的点\r\n     */\r\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\r\n        var a = rx;\r\n        var b = ry;\r\n        // 假如椭圆半径为0则返回圆心\r\n        if (a === 0 || b === 0) {\r\n            return {\r\n                x: x,\r\n                y: y,\r\n            };\r\n        }\r\n        // 转换成 0， 0 为中心的椭圆计算\r\n        var relativeX = x0 - x;\r\n        var relativeY = y0 - y;\r\n        var px = Math.abs(relativeX);\r\n        var py = Math.abs(relativeY);\r\n        var squareA = a * a;\r\n        var squareB = b * b;\r\n        // const angle0 = Math.atan2(relativeY, relativeX);\r\n        var t = Math.PI / 4;\r\n        var nearestX; // 椭圆上的任一点\r\n        var nearestY;\r\n        // 迭代 4 次\r\n        for (var i = 0; i < 4; i++) {\r\n            nearestX = a * Math.cos(t);\r\n            nearestY = b * Math.sin(t);\r\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\r\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\r\n            var rx1 = nearestX - ex;\r\n            var ry1 = nearestY - ey;\r\n            var qx = px - ex;\r\n            var qy = py - ey;\r\n            var r = Math.hypot(ry1, rx1);\r\n            var q = Math.hypot(qy, qx);\r\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\r\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\r\n            t += delta_t;\r\n            t = Math.min(Math.PI / 2, Math.max(0, t));\r\n        }\r\n        return {\r\n            x: x + copysign(nearestX, relativeX),\r\n            y: y + copysign(nearestY, relativeY),\r\n        };\r\n    },\r\n    /**\r\n     * 点到椭圆最近的距离\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} x0  指定的点 x\r\n     * @param {number} y0  指定的点 y\r\n     * @return {number} 点到椭圆的距离\r\n     */\r\n    pointDistance: function (x, y, rx, ry, x0, y0) {\r\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\r\n        return distance(nearestPoint.x, nearestPoint.y, x0, y0);\r\n    },\r\n    /**\r\n     * 根据比例获取点\r\n     * @param {number} x 椭圆中心 x\r\n     * @param {number} y 椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} t 指定比例，x轴方向为 0\r\n     * @return {object} 点\r\n     */\r\n    pointAt: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\r\n        return {\r\n            x: x + rx * Math.cos(angle),\r\n            y: y + ry * Math.sin(angle),\r\n        };\r\n    },\r\n    /**\r\n     * 根据比例计算切线角度\r\n     * @param {number} x 椭圆中心 x\r\n     * @param {number} y 椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\r\n     * @return {number} 角度，在 0 - 2PI 之间\r\n     */\r\n    tangentAngle: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\r\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\r\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\r\n        // 也可以使用指定点的切线方程计算，成本有些高\r\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\r\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\r\n        // if (angle >= 0 && angle <= Math.PI) {\r\n        //   tangentAngle += Math.PI;\r\n        // }\r\n        return piMod(tangentAngle);\r\n    },\r\n};\r\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}