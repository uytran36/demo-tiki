{"ast":null,"code":"/**\r\n * @fileOverview MDS layout\r\n * @author shiwu.wyy@antfin.com\r\n */\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n/**\r\n * mds 布局\r\n */\n\nexport class MDSLayout extends Base {\n  constructor(options) {\n    super();\n    /** 布局中心 */\n\n    this.center = [0, 0];\n    /** 边长度 */\n\n    this.linkDistance = 50;\n    this.nodes = [];\n    this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  }\n  /**\r\n   * 执行布局\r\n   */\n\n\n  execute() {\n    const self = this;\n    const {\n      nodes,\n      edges = []\n    } = self;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    const linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n    const adjMatrix = getAdjMatrix({\n      nodes,\n      edges\n    }, false);\n    const distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n    const scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD; // get positions by MDS\n\n    const positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach((p, i) => {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n  /**\r\n   * mds 算法\r\n   * @return {array} positions 计算后的节点位置数组\r\n   */\n\n\n  runMDS() {\n    const self = this;\n    const dimension = 2;\n    const distances = self.scaledDistances; // square distances\n\n    const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n    const rowMeans = M.mean(\"row\");\n    const colMeans = M.mean(\"column\");\n    const totalMean = M.mean();\n    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n    // points from it\n\n    const ret = new SingularValueDecomposition(M);\n    const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map(row => {\n      return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n    });\n  }\n\n  handleInfinity(distances) {\n    let maxDistance = -999999;\n    distances.forEach(row => {\n      row.forEach(value => {\n        if (value === Infinity) {\n          return;\n        }\n\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach((row, i) => {\n      row.forEach((value, j) => {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  }\n\n  getType() {\n    return \"mds\";\n  }\n\n}","map":{"version":3,"sources":["../../src/layout/mds.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @fileOverview MDS layout\r\n * @author shiwu.wyy@antfin.com\r\n */\r\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\r\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\r\nimport { Base } from \"./base\";\r\n/**\r\n * mds 布局\r\n */\r\nexport class MDSLayout extends Base {\r\n    constructor(options) {\r\n        super();\r\n        /** 布局中心 */\r\n        this.center = [0, 0];\r\n        /** 边长度 */\r\n        this.linkDistance = 50;\r\n        this.nodes = [];\r\n        this.edges = [];\r\n        /** 迭代结束的回调函数 */\r\n        this.onLayoutEnd = () => { };\r\n        this.updateCfg(options);\r\n    }\r\n    getDefaultCfg() {\r\n        return {\r\n            center: [0, 0],\r\n            linkDistance: 50\r\n        };\r\n    }\r\n    /**\r\n     * 执行布局\r\n     */\r\n    execute() {\r\n        const self = this;\r\n        const { nodes, edges = [] } = self;\r\n        const center = self.center;\r\n        if (!nodes || nodes.length === 0) {\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return;\r\n        }\r\n        if (nodes.length === 1) {\r\n            nodes[0].x = center[0];\r\n            nodes[0].y = center[1];\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return;\r\n        }\r\n        const linkDistance = self.linkDistance;\r\n        // the graph-theoretic distance (shortest path distance) matrix\r\n        const adjMatrix = getAdjMatrix({ nodes, edges }, false);\r\n        const distances = floydWarshall(adjMatrix);\r\n        self.handleInfinity(distances);\r\n        // scale the ideal edge length acoording to linkDistance\r\n        const scaledD = scaleMatrix(distances, linkDistance);\r\n        self.scaledDistances = scaledD;\r\n        // get positions by MDS\r\n        const positions = self.runMDS();\r\n        self.positions = positions;\r\n        positions.forEach((p, i) => {\r\n            nodes[i].x = p[0] + center[0];\r\n            nodes[i].y = p[1] + center[1];\r\n        });\r\n        if (self.onLayoutEnd)\r\n            self.onLayoutEnd();\r\n        return {\r\n            nodes,\r\n            edges\r\n        };\r\n    }\r\n    /**\r\n     * mds 算法\r\n     * @return {array} positions 计算后的节点位置数组\r\n     */\r\n    runMDS() {\r\n        const self = this;\r\n        const dimension = 2;\r\n        const distances = self.scaledDistances;\r\n        // square distances\r\n        const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\r\n        // double centre the rows/columns\r\n        const rowMeans = M.mean(\"row\");\r\n        const colMeans = M.mean(\"column\");\r\n        const totalMean = M.mean();\r\n        M.add(totalMean)\r\n            .subRowVector(rowMeans)\r\n            .subColumnVector(colMeans);\r\n        // take the SVD of the double centred matrix, and return the\r\n        // points from it\r\n        const ret = new SingularValueDecomposition(M);\r\n        const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\r\n        return ret.leftSingularVectors.toJSON().map((row) => {\r\n            return MLMatrix.mul([row], [eigenValues])\r\n                .toJSON()[0]\r\n                .splice(0, dimension);\r\n        });\r\n    }\r\n    handleInfinity(distances) {\r\n        let maxDistance = -999999;\r\n        distances.forEach((row) => {\r\n            row.forEach((value) => {\r\n                if (value === Infinity) {\r\n                    return;\r\n                }\r\n                if (maxDistance < value) {\r\n                    maxDistance = value;\r\n                }\r\n            });\r\n        });\r\n        distances.forEach((row, i) => {\r\n            row.forEach((value, j) => {\r\n                if (value === Infinity) {\r\n                    distances[i][j] = maxDistance;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getType() {\r\n        return \"mds\";\r\n    }\r\n}\r\n//# sourceMappingURL=mds.js.map"]},"metadata":{},"sourceType":"module"}