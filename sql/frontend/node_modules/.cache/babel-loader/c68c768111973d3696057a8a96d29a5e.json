{"ast":null,"code":"/**\r\n * @fileOverview grid layout\r\n * @author shiwu.wyy@antfin.com\r\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\r\n */\nimport { isString, isArray, isNumber, getDegree, isNaN, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\r\n * 网格布局\r\n */\n\nexport class GridLayout extends Base {\n  constructor(options) {\n    super();\n    /** 布局起始点 */\n\n    this.begin = [0, 0];\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    this.preventOverlap = true;\n    /** extra spacing around nodes when preventOverlap: true */\n\n    this.preventOverlapPadding = 10;\n    /** uses all available space on false, uses minimal space on true */\n\n    this.condense = false;\n    /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n\n    this.sortBy = \"degree\";\n    this.nodeSize = 30;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.row = 0;\n    this.col = 0;\n    this.cellWidth = 0;\n    this.cellHeight = 0;\n    this.cellUsed = {};\n    this.id2manPos = {};\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      begin: [0, 0],\n      preventOverlap: true,\n      preventOverlapPadding: 10,\n      condense: false,\n      rows: undefined,\n      cols: undefined,\n      position: undefined,\n      sortBy: \"degree\",\n      nodeSize: 30\n    };\n  }\n  /**\r\n   * 执行布局\r\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n    const begin = self.begin;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes,\n        edges\n      };\n    }\n\n    if (n === 1) {\n      nodes[0].x = begin[0];\n      nodes[0].y = begin[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes,\n        edges\n      };\n    }\n\n    const layoutNodes = [];\n    nodes.forEach(node => {\n      layoutNodes.push(node);\n    });\n    const nodeIdxMap = {};\n    layoutNodes.forEach((node, i) => {\n      nodeIdxMap[node.id] = i;\n    });\n\n    if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n\n      if (isNaN(nodes[0].degree)) {\n        const values = getDegree(layoutNodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach((node, i) => {\n          node.degree = values[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    const oRows = self.rows;\n    const oCols = self.cols != null ? self.cols : self.columns;\n    self.cells = n; // if rows or columns were set in self, use those values\n\n    if (oRows != null && oCols != null) {\n      self.rows = oRows;\n      self.cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      self.rows = oRows;\n      self.cols = Math.ceil(self.cells / self.rows);\n    } else if (oRows == null && oCols != null) {\n      self.cols = oCols;\n      self.rows = Math.ceil(self.cells / self.cols);\n    } else {\n      // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n      // width/height * splits^2 = cells where splits is number of times to split width\n      self.splits = Math.sqrt(self.cells * self.height / self.width);\n      self.rows = Math.round(self.splits);\n      self.cols = Math.round(self.width / self.height * self.splits);\n    }\n\n    if (self.cols * self.rows > self.cells) {\n      // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      const sm = self.small();\n      const lg = self.large(); // reducing the small side takes away the most cells, so try it first\n\n      if ((sm - 1) * lg >= self.cells) {\n        self.small(sm - 1);\n      } else if ((lg - 1) * sm >= self.cells) {\n        self.large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (self.cols * self.rows < self.cells) {\n        const sm = self.small();\n        const lg = self.large(); // try to add to larger side first (adds less in multiplication)\n\n        if ((lg + 1) * sm >= self.cells) {\n          self.large(lg + 1);\n        } else {\n          self.small(sm + 1);\n        }\n      }\n    }\n\n    self.cellWidth = self.width / self.cols;\n    self.cellHeight = self.height / self.rows;\n\n    if (self.condense) {\n      self.cellWidth = 0;\n      self.cellHeight = 0;\n    }\n\n    if (self.preventOverlap) {\n      layoutNodes.forEach(node => {\n        if (!node.x || !node.y) {\n          // for bb\n          node.x = 0;\n          node.y = 0;\n        }\n\n        let nodew;\n        let nodeh;\n\n        if (isArray(node.size)) {\n          nodew = node.size[0];\n          nodeh = node.size[1];\n        } else if (isNumber(node.size)) {\n          nodew = node.size;\n          nodeh = node.size;\n        } else if (isObject(node.size)) {\n          nodew = node.size.width;\n          nodeh = node.size.height;\n        }\n\n        if (nodew === undefined || nodeh === undefined) {\n          if (isArray(self.nodeSize)) {\n            nodew = self.nodeSize[0];\n            nodeh = self.nodeSize[1];\n          } else if (isNumber(self.nodeSize)) {\n            nodew = self.nodeSize;\n            nodeh = self.nodeSize;\n          } else {\n            nodew = 30;\n            nodeh = 30;\n          }\n        }\n\n        const p = self.preventOverlapPadding;\n        const w = nodew + p;\n        const h = nodeh + p;\n        self.cellWidth = Math.max(self.cellWidth, w);\n        self.cellHeight = Math.max(self.cellHeight, h);\n      });\n    }\n\n    self.cellUsed = {}; // e.g. 'c-0-2' => true\n    // to keep track of current cell position\n\n    self.row = 0;\n    self.col = 0; // get a cache of all the manual positions\n\n    self.id2manPos = {};\n\n    for (let i = 0; i < layoutNodes.length; i++) {\n      const node = layoutNodes[i];\n      let rcPos;\n\n      if (self.position) {\n        rcPos = self.position(node);\n      }\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        const pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (pos.col === undefined) {\n          // find unused col\n          pos.col = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.col++;\n          }\n        } else if (pos.row === undefined) {\n          // find unused row\n          pos.row = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.row++;\n          }\n        }\n\n        self.id2manPos[node.id] = pos;\n        self.use(pos.row, pos.col);\n      }\n\n      self.getPos(node);\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      edges,\n      nodes: layoutNodes\n    };\n  }\n\n  small(val) {\n    const self = this;\n    let res;\n    const rows = self.rows || 5;\n    const cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.min(rows, cols);\n    } else {\n      const min = Math.min(rows, cols);\n\n      if (min === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  }\n\n  large(val) {\n    const self = this;\n    let res;\n    const rows = self.rows || 5;\n    const cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.max(rows, cols);\n    } else {\n      const max = Math.max(rows, cols);\n\n      if (max === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  }\n\n  used(row, col) {\n    const self = this;\n    return self.cellUsed[`c-${row}-${col}`] || false;\n  }\n\n  use(row, col) {\n    const self = this;\n    self.cellUsed[`c-${row}-${col}`] = true;\n  }\n\n  moveToNextCell() {\n    const self = this;\n    const cols = self.cols || 5;\n    self.col++;\n\n    if (self.col >= cols) {\n      self.col = 0;\n      self.row++;\n    }\n  }\n\n  getPos(node) {\n    const self = this;\n    const begin = self.begin;\n    const cellWidth = self.cellWidth;\n    const cellHeight = self.cellHeight;\n    let x;\n    let y; // see if we have a manual position set\n\n    const rcPos = self.id2manPos[node.id];\n\n    if (rcPos) {\n      x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n      y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n    } else {\n      // otherwise set automatically\n      while (self.used(self.row, self.col)) {\n        self.moveToNextCell();\n      }\n\n      x = self.col * cellWidth + cellWidth / 2 + begin[0];\n      y = self.row * cellHeight + cellHeight / 2 + begin[1];\n      self.use(self.row, self.col);\n      self.moveToNextCell();\n    }\n\n    node.x = x;\n    node.y = y;\n  }\n\n  getType() {\n    return \"grid\";\n  }\n\n}","map":{"version":3,"sources":["../../src/layout/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * @fileOverview grid layout\r\n * @author shiwu.wyy@antfin.com\r\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\r\n */\r\nimport { isString, isArray, isNumber, getDegree, isNaN, isObject } from \"../util\";\r\nimport { Base } from \"./base\";\r\n/**\r\n * 网格布局\r\n */\r\nexport class GridLayout extends Base {\r\n    constructor(options) {\r\n        super();\r\n        /** 布局起始点 */\r\n        this.begin = [0, 0];\r\n        /** prevents node overlap, may overflow boundingBox if not enough space */\r\n        this.preventOverlap = true;\r\n        /** extra spacing around nodes when preventOverlap: true */\r\n        this.preventOverlapPadding = 10;\r\n        /** uses all available space on false, uses minimal space on true */\r\n        this.condense = false;\r\n        /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\r\n        this.sortBy = \"degree\";\r\n        this.nodeSize = 30;\r\n        this.nodes = [];\r\n        this.edges = [];\r\n        this.width = 300;\r\n        this.height = 300;\r\n        this.row = 0;\r\n        this.col = 0;\r\n        this.cellWidth = 0;\r\n        this.cellHeight = 0;\r\n        this.cellUsed = {};\r\n        this.id2manPos = {};\r\n        /** 迭代结束的回调函数 */\r\n        this.onLayoutEnd = () => { };\r\n        this.updateCfg(options);\r\n    }\r\n    getDefaultCfg() {\r\n        return {\r\n            begin: [0, 0],\r\n            preventOverlap: true,\r\n            preventOverlapPadding: 10,\r\n            condense: false,\r\n            rows: undefined,\r\n            cols: undefined,\r\n            position: undefined,\r\n            sortBy: \"degree\",\r\n            nodeSize: 30\r\n        };\r\n    }\r\n    /**\r\n     * 执行布局\r\n     */\r\n    execute() {\r\n        const self = this;\r\n        const nodes = self.nodes;\r\n        const edges = self.edges;\r\n        const n = nodes.length;\r\n        const begin = self.begin;\r\n        if (n === 0) {\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return {\r\n                nodes,\r\n                edges\r\n            };\r\n        }\r\n        if (n === 1) {\r\n            nodes[0].x = begin[0];\r\n            nodes[0].y = begin[1];\r\n            if (self.onLayoutEnd)\r\n                self.onLayoutEnd();\r\n            return {\r\n                nodes,\r\n                edges,\r\n            };\r\n        }\r\n        const layoutNodes = [];\r\n        nodes.forEach((node) => {\r\n            layoutNodes.push(node);\r\n        });\r\n        const nodeIdxMap = {};\r\n        layoutNodes.forEach((node, i) => {\r\n            nodeIdxMap[node.id] = i;\r\n        });\r\n        if (self.sortBy === \"degree\" ||\r\n            !isString(self.sortBy) ||\r\n            layoutNodes[0][self.sortBy] === undefined) {\r\n            self.sortBy = \"degree\";\r\n            if (isNaN(nodes[0].degree)) {\r\n                const values = getDegree(layoutNodes.length, nodeIdxMap, edges);\r\n                layoutNodes.forEach((node, i) => {\r\n                    node.degree = values[i];\r\n                });\r\n            }\r\n        }\r\n        // sort nodes by value\r\n        layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\r\n        if (!self.width && typeof window !== \"undefined\") {\r\n            self.width = window.innerWidth;\r\n        }\r\n        if (!self.height && typeof window !== \"undefined\") {\r\n            self.height = window.innerHeight;\r\n        }\r\n        const oRows = self.rows;\r\n        const oCols = self.cols != null ? self.cols : self.columns;\r\n        self.cells = n;\r\n        // if rows or columns were set in self, use those values\r\n        if (oRows != null && oCols != null) {\r\n            self.rows = oRows;\r\n            self.cols = oCols;\r\n        }\r\n        else if (oRows != null && oCols == null) {\r\n            self.rows = oRows;\r\n            self.cols = Math.ceil(self.cells / self.rows);\r\n        }\r\n        else if (oRows == null && oCols != null) {\r\n            self.cols = oCols;\r\n            self.rows = Math.ceil(self.cells / self.cols);\r\n        }\r\n        else {\r\n            // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\r\n            // width/height * splits^2 = cells where splits is number of times to split width\r\n            self.splits = Math.sqrt((self.cells * self.height) / self.width);\r\n            self.rows = Math.round(self.splits);\r\n            self.cols = Math.round((self.width / self.height) * self.splits);\r\n        }\r\n        if (self.cols * self.rows > self.cells) {\r\n            // otherwise use the automatic values and adjust accordingly\r\n            // if rounding was up, see if we can reduce rows or columns\r\n            const sm = self.small();\r\n            const lg = self.large();\r\n            // reducing the small side takes away the most cells, so try it first\r\n            if ((sm - 1) * lg >= self.cells) {\r\n                self.small(sm - 1);\r\n            }\r\n            else if ((lg - 1) * sm >= self.cells) {\r\n                self.large(lg - 1);\r\n            }\r\n        }\r\n        else {\r\n            // if rounding was too low, add rows or columns\r\n            while (self.cols * self.rows < self.cells) {\r\n                const sm = self.small();\r\n                const lg = self.large();\r\n                // try to add to larger side first (adds less in multiplication)\r\n                if ((lg + 1) * sm >= self.cells) {\r\n                    self.large(lg + 1);\r\n                }\r\n                else {\r\n                    self.small(sm + 1);\r\n                }\r\n            }\r\n        }\r\n        self.cellWidth = self.width / self.cols;\r\n        self.cellHeight = self.height / self.rows;\r\n        if (self.condense) {\r\n            self.cellWidth = 0;\r\n            self.cellHeight = 0;\r\n        }\r\n        if (self.preventOverlap) {\r\n            layoutNodes.forEach((node) => {\r\n                if (!node.x || !node.y) {\r\n                    // for bb\r\n                    node.x = 0;\r\n                    node.y = 0;\r\n                }\r\n                let nodew;\r\n                let nodeh;\r\n                if (isArray(node.size)) {\r\n                    nodew = node.size[0];\r\n                    nodeh = node.size[1];\r\n                }\r\n                else if (isNumber(node.size)) {\r\n                    nodew = node.size;\r\n                    nodeh = node.size;\r\n                }\r\n                else if (isObject(node.size)) {\r\n                    nodew = node.size.width;\r\n                    nodeh = node.size.height;\r\n                }\r\n                if (nodew === undefined || nodeh === undefined) {\r\n                    if (isArray(self.nodeSize)) {\r\n                        nodew = self.nodeSize[0];\r\n                        nodeh = self.nodeSize[1];\r\n                    }\r\n                    else if (isNumber(self.nodeSize)) {\r\n                        nodew = self.nodeSize;\r\n                        nodeh = self.nodeSize;\r\n                    }\r\n                    else {\r\n                        nodew = 30;\r\n                        nodeh = 30;\r\n                    }\r\n                }\r\n                const p = self.preventOverlapPadding;\r\n                const w = nodew + p;\r\n                const h = nodeh + p;\r\n                self.cellWidth = Math.max(self.cellWidth, w);\r\n                self.cellHeight = Math.max(self.cellHeight, h);\r\n            });\r\n        }\r\n        self.cellUsed = {}; // e.g. 'c-0-2' => true\r\n        // to keep track of current cell position\r\n        self.row = 0;\r\n        self.col = 0;\r\n        // get a cache of all the manual positions\r\n        self.id2manPos = {};\r\n        for (let i = 0; i < layoutNodes.length; i++) {\r\n            const node = layoutNodes[i];\r\n            let rcPos;\r\n            if (self.position) {\r\n                rcPos = self.position(node);\r\n            }\r\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\r\n                // must have at least row or col def'd\r\n                const pos = {\r\n                    row: rcPos.row,\r\n                    col: rcPos.col\r\n                };\r\n                if (pos.col === undefined) {\r\n                    // find unused col\r\n                    pos.col = 0;\r\n                    while (self.used(pos.row, pos.col)) {\r\n                        pos.col++;\r\n                    }\r\n                }\r\n                else if (pos.row === undefined) {\r\n                    // find unused row\r\n                    pos.row = 0;\r\n                    while (self.used(pos.row, pos.col)) {\r\n                        pos.row++;\r\n                    }\r\n                }\r\n                self.id2manPos[node.id] = pos;\r\n                self.use(pos.row, pos.col);\r\n            }\r\n            self.getPos(node);\r\n        }\r\n        if (self.onLayoutEnd)\r\n            self.onLayoutEnd();\r\n        return {\r\n            edges,\r\n            nodes: layoutNodes\r\n        };\r\n    }\r\n    small(val) {\r\n        const self = this;\r\n        let res;\r\n        const rows = self.rows || 5;\r\n        const cols = self.cols || 5;\r\n        if (val == null) {\r\n            res = Math.min(rows, cols);\r\n        }\r\n        else {\r\n            const min = Math.min(rows, cols);\r\n            if (min === self.rows) {\r\n                self.rows = val;\r\n            }\r\n            else {\r\n                self.cols = val;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    large(val) {\r\n        const self = this;\r\n        let res;\r\n        const rows = self.rows || 5;\r\n        const cols = self.cols || 5;\r\n        if (val == null) {\r\n            res = Math.max(rows, cols);\r\n        }\r\n        else {\r\n            const max = Math.max(rows, cols);\r\n            if (max === self.rows) {\r\n                self.rows = val;\r\n            }\r\n            else {\r\n                self.cols = val;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    used(row, col) {\r\n        const self = this;\r\n        return self.cellUsed[`c-${row}-${col}`] || false;\r\n    }\r\n    use(row, col) {\r\n        const self = this;\r\n        self.cellUsed[`c-${row}-${col}`] = true;\r\n    }\r\n    moveToNextCell() {\r\n        const self = this;\r\n        const cols = self.cols || 5;\r\n        self.col++;\r\n        if (self.col >= cols) {\r\n            self.col = 0;\r\n            self.row++;\r\n        }\r\n    }\r\n    getPos(node) {\r\n        const self = this;\r\n        const begin = self.begin;\r\n        const cellWidth = self.cellWidth;\r\n        const cellHeight = self.cellHeight;\r\n        let x;\r\n        let y;\r\n        // see if we have a manual position set\r\n        const rcPos = self.id2manPos[node.id];\r\n        if (rcPos) {\r\n            x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\r\n            y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\r\n        }\r\n        else {\r\n            // otherwise set automatically\r\n            while (self.used(self.row, self.col)) {\r\n                self.moveToNextCell();\r\n            }\r\n            x = self.col * cellWidth + cellWidth / 2 + begin[0];\r\n            y = self.row * cellHeight + cellHeight / 2 + begin[1];\r\n            self.use(self.row, self.col);\r\n            self.moveToNextCell();\r\n        }\r\n        node.x = x;\r\n        node.y = y;\r\n    }\r\n    getType() {\r\n        return \"grid\";\r\n    }\r\n}\r\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}