{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\n\nvar Line =\n/** @class */\nfunction (_super) {\n  __extends(Line, _super);\n\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Line.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'line',\n      locationType: 'region',\n\n      /**\r\n       * 起始点, x, y\r\n       * @type {object}\r\n       */\n      start: null,\n\n      /**\r\n       * 结束点, x, y\r\n       * @type {object}\r\n       */\n      end: null\n    });\n  }; // 获取坐标轴线的 path\n\n\n  Line.prototype.getLinePath = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    var path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  }; // 重新计算 layout bbox，考虑到 line 不显示\n\n\n  Line.prototype.getInnerLayoutBBox = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n\n    var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n\n    var minX = Math.min(start.x, end.x, bbox.x);\n    var minY = Math.min(start.y, end.y, bbox.y);\n    var maxX = Math.max(start.x, end.x, bbox.maxX);\n    var maxY = Math.max(start.y, end.y, bbox.maxY);\n    return {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  };\n\n  Line.prototype.isVertical = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.x, end.x);\n  };\n\n  Line.prototype.isHorizontal = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.y, end.y);\n  };\n\n  Line.prototype.getTickPoint = function (tickValue) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var regionX = end.x - start.x;\n    var regionY = end.y - start.y;\n    return {\n      x: start.x + regionX * tickValue,\n      y: start.y + regionY * tickValue\n    };\n  }; // 直线坐标轴下任一点的向量方向都相同\n\n\n  Line.prototype.getSideVector = function (offset) {\n    var axisVector = this.getAxisVector();\n    var normal = vec2.normalize([0, 0], axisVector);\n    var factor = this.get('verticalFactor');\n    var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n\n    return vec2.scale([0, 0], verticalVector, offset * factor);\n  }; // 获取坐标轴的向量\n\n\n  Line.prototype.getAxisVector = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  Line.prototype.processOverlap = function (labelGroup) {\n    var _this = this;\n\n    var isVertical = this.isVertical();\n    var isHorizontal = this.isHorizontal(); // 非垂直，或者非水平时不处理遮挡问题\n\n    if (!isVertical && !isHorizontal) {\n      return;\n    }\n\n    var labelCfg = this.get('label');\n    var titleCfg = this.get('title');\n    var verticalLimitLength = this.get('verticalLimitLength');\n    var labelOffset = labelCfg.offset;\n    var limitLength = verticalLimitLength;\n    var titleHeight = 0;\n    var titleSpacing = 0;\n\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n\n    var overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, function (name) {\n      if (labelCfg[name] && _this.canProcessOverlap(name)) {\n        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        var bbox = labelGroup.getCanvasBBox();\n        var length_1 = isVertical ? bbox.width : bbox.height; // 如果用户没有设置 offset，则自动计算\n\n        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n      }\n    }\n  };\n  /**\r\n   * 是否可以执行某一 overlap\r\n   * @param name\r\n   */\n\n\n  Line.prototype.canProcessOverlap = function (name) {\n    var labelCfg = this.get('label'); // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    } // 默认所有 overlap 都可执行\n\n\n    return true;\n  };\n\n  Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n    var _this = this;\n\n    var isVertical = this.isVertical();\n    var hasAdjusted = false;\n    var util = OverlapUtil[name];\n\n    if (value === true) {\n      var labelCfg = this.get('label'); // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n\n      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n    } else if (isFunction(value)) {\n      // 回调函数形式的配置： 用户可以传入回调函数\n      hasAdjusted = value(isVertical, labelGroup, limitLength);\n    } else if (isObject(value)) {\n      // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n      var overlapCfg = value;\n\n      if (util[overlapCfg.type]) {\n        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n      }\n    } else if (util[value]) {\n      // 字符串类型的配置：按照名称执行 overlap 处理方法\n      hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n    }\n\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        var labels = labelGroup.getChildren();\n        var verticalFactor_1 = this.get('verticalFactor');\n        each(labels, function (label) {\n          var textAlign = label.attr('textAlign');\n\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n\n      each(children, function (label) {\n        if (!label.get('visible')) {\n          if (_this.get('isRegister')) {\n            // 已经注册过了，则删除\n            _this.unregisterElement(label);\n          }\n\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  };\n\n  return Line;\n}(AxisBase);\n\nexport default Line;","map":{"version":3,"sources":["../../src/axis/line.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\r\nimport { vec2 } from '@antv/matrix-util';\r\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\r\nimport AxisBase from './base';\r\nimport * as OverlapUtil from './overlap';\r\nvar Line = /** @class */ (function (_super) {\r\n    __extends(Line, _super);\r\n    function Line() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Line.prototype.getDefaultCfg = function () {\r\n        var cfg = _super.prototype.getDefaultCfg.call(this);\r\n        return __assign(__assign({}, cfg), { type: 'line', locationType: 'region', \r\n            /**\r\n             * 起始点, x, y\r\n             * @type {object}\r\n             */\r\n            start: null, \r\n            /**\r\n             * 结束点, x, y\r\n             * @type {object}\r\n             */\r\n            end: null });\r\n    };\r\n    // 获取坐标轴线的 path\r\n    Line.prototype.getLinePath = function () {\r\n        var start = this.get('start');\r\n        var end = this.get('end');\r\n        var path = [];\r\n        path.push(['M', start.x, start.y]);\r\n        path.push(['L', end.x, end.y]);\r\n        return path;\r\n    };\r\n    // 重新计算 layout bbox，考虑到 line 不显示\r\n    Line.prototype.getInnerLayoutBBox = function () {\r\n        var start = this.get('start');\r\n        var end = this.get('end');\r\n        var bbox = _super.prototype.getInnerLayoutBBox.call(this);\r\n        var minX = Math.min(start.x, end.x, bbox.x);\r\n        var minY = Math.min(start.y, end.y, bbox.y);\r\n        var maxX = Math.max(start.x, end.x, bbox.maxX);\r\n        var maxY = Math.max(start.y, end.y, bbox.maxY);\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            minX: minX,\r\n            minY: minY,\r\n            maxX: maxX,\r\n            maxY: maxY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n    };\r\n    Line.prototype.isVertical = function () {\r\n        var start = this.get('start');\r\n        var end = this.get('end');\r\n        return isNumberEqual(start.x, end.x);\r\n    };\r\n    Line.prototype.isHorizontal = function () {\r\n        var start = this.get('start');\r\n        var end = this.get('end');\r\n        return isNumberEqual(start.y, end.y);\r\n    };\r\n    Line.prototype.getTickPoint = function (tickValue) {\r\n        var self = this;\r\n        var start = self.get('start');\r\n        var end = self.get('end');\r\n        var regionX = end.x - start.x;\r\n        var regionY = end.y - start.y;\r\n        return {\r\n            x: start.x + regionX * tickValue,\r\n            y: start.y + regionY * tickValue,\r\n        };\r\n    };\r\n    // 直线坐标轴下任一点的向量方向都相同\r\n    Line.prototype.getSideVector = function (offset) {\r\n        var axisVector = this.getAxisVector();\r\n        var normal = vec2.normalize([0, 0], axisVector);\r\n        var factor = this.get('verticalFactor');\r\n        var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\r\n        return vec2.scale([0, 0], verticalVector, offset * factor);\r\n    };\r\n    // 获取坐标轴的向量\r\n    Line.prototype.getAxisVector = function () {\r\n        var start = this.get('start');\r\n        var end = this.get('end');\r\n        return [end.x - start.x, end.y - start.y];\r\n    };\r\n    Line.prototype.processOverlap = function (labelGroup) {\r\n        var _this = this;\r\n        var isVertical = this.isVertical();\r\n        var isHorizontal = this.isHorizontal();\r\n        // 非垂直，或者非水平时不处理遮挡问题\r\n        if (!isVertical && !isHorizontal) {\r\n            return;\r\n        }\r\n        var labelCfg = this.get('label');\r\n        var titleCfg = this.get('title');\r\n        var verticalLimitLength = this.get('verticalLimitLength');\r\n        var labelOffset = labelCfg.offset;\r\n        var limitLength = verticalLimitLength;\r\n        var titleHeight = 0;\r\n        var titleSpacing = 0;\r\n        if (titleCfg) {\r\n            titleHeight = titleCfg.style.fontSize;\r\n            titleSpacing = titleCfg.spacing;\r\n        }\r\n        if (limitLength) {\r\n            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\r\n        }\r\n        var overlapOrder = this.get('overlapOrder');\r\n        each(overlapOrder, function (name) {\r\n            if (labelCfg[name] && _this.canProcessOverlap(name)) {\r\n                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\r\n            }\r\n        });\r\n        if (titleCfg) {\r\n            if (isNil(titleCfg.offset)) {\r\n                // 调整 title 的 offset\r\n                var bbox = labelGroup.getCanvasBBox();\r\n                var length_1 = isVertical ? bbox.width : bbox.height;\r\n                // 如果用户没有设置 offset，则自动计算\r\n                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 是否可以执行某一 overlap\r\n     * @param name\r\n     */\r\n    Line.prototype.canProcessOverlap = function (name) {\r\n        var labelCfg = this.get('label');\r\n        // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\r\n        if (name === 'autoRotate') {\r\n            return isNil(labelCfg.rotate);\r\n        }\r\n        // 默认所有 overlap 都可执行\r\n        return true;\r\n    };\r\n    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\r\n        var _this = this;\r\n        var isVertical = this.isVertical();\r\n        var hasAdjusted = false;\r\n        var util = OverlapUtil[name];\r\n        if (value === true) {\r\n            var labelCfg = this.get('label');\r\n            // true 形式的配置：使用 overlap 默认的的处理方法进行处理\r\n            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\r\n        }\r\n        else if (isFunction(value)) {\r\n            // 回调函数形式的配置： 用户可以传入回调函数\r\n            hasAdjusted = value(isVertical, labelGroup, limitLength);\r\n        }\r\n        else if (isObject(value)) {\r\n            // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\r\n            var overlapCfg = value;\r\n            if (util[overlapCfg.type]) {\r\n                hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\r\n            }\r\n        }\r\n        else if (util[value]) {\r\n            // 字符串类型的配置：按照名称执行 overlap 处理方法\r\n            hasAdjusted = util[value](isVertical, labelGroup, limitLength);\r\n        }\r\n        if (name === 'autoRotate') {\r\n            // 文本旋转后，文本的对齐方式可能就不合适了\r\n            if (hasAdjusted) {\r\n                var labels = labelGroup.getChildren();\r\n                var verticalFactor_1 = this.get('verticalFactor');\r\n                each(labels, function (label) {\r\n                    var textAlign = label.attr('textAlign');\r\n                    if (textAlign === 'center') {\r\n                        // 居中的文本需要调整旋转度\r\n                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\r\n                        label.attr('textAlign', newAlign);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        else if (name === 'autoHide') {\r\n            var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\r\n            each(children, function (label) {\r\n                if (!label.get('visible')) {\r\n                    if (_this.get('isRegister')) {\r\n                        // 已经注册过了，则删除\r\n                        _this.unregisterElement(label);\r\n                    }\r\n                    label.remove(); // 防止 label 数量太多，所以统一删除\r\n                }\r\n            });\r\n        }\r\n    };\r\n    return Line;\r\n}(AxisBase));\r\nexport default Line;\r\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}