{"ast":null,"code":"var _ = require(\"../lodash\");\n\nmodule.exports = addSubgraphConstraints;\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {},\n      rootPrev;\n\n  _.forEach(vs, function (v) {\n    var child = g.parent(v),\n        parent,\n        prevChild;\n\n    while (child) {\n      parent = g.parent(child);\n\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n\n      child = parent;\n    }\n  });\n  /*\r\n  function dfs(v) {\r\n    var children = v ? g.children(v) : g.children();\r\n    if (children.length) {\r\n      var min = Number.POSITIVE_INFINITY,\r\n          subgraphs = [];\r\n      _.each(children, function(child) {\r\n        var childMin = dfs(child);\r\n        if (g.children(child).length) {\r\n          subgraphs.push({ v: child, order: childMin });\r\n        }\r\n        min = Math.min(min, childMin);\r\n      });\r\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\r\n        cg.setEdge(prev.v, curr.v);\r\n        return curr;\r\n      });\r\n      return min;\r\n    }\r\n    return g.node(v).order;\r\n  }\r\n  dfs(undefined);\r\n  */\n\n}","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/dagre/lib/order/add-subgraph-constraints.js"],"names":["_","require","module","exports","addSubgraphConstraints","g","cg","vs","prev","rootPrev","forEach","v","child","parent","prevChild","setEdge"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,WAAD,CAAf;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,sBAAjB;;AAEA,SAASA,sBAAT,CAAgCC,CAAhC,EAAmCC,EAAnC,EAAuCC,EAAvC,EAA2C;AACzC,MAAIC,IAAI,GAAG,EAAX;AAAA,MACEC,QADF;;AAGAT,EAAAA,CAAC,CAACU,OAAF,CAAUH,EAAV,EAAc,UAASI,CAAT,EAAY;AACxB,QAAIC,KAAK,GAAGP,CAAC,CAACQ,MAAF,CAASF,CAAT,CAAZ;AAAA,QACEE,MADF;AAAA,QAEEC,SAFF;;AAGA,WAAOF,KAAP,EAAc;AACZC,MAAAA,MAAM,GAAGR,CAAC,CAACQ,MAAF,CAASD,KAAT,CAAT;;AACA,UAAIC,MAAJ,EAAY;AACVC,QAAAA,SAAS,GAAGN,IAAI,CAACK,MAAD,CAAhB;AACAL,QAAAA,IAAI,CAACK,MAAD,CAAJ,GAAeD,KAAf;AACD,OAHD,MAGO;AACLE,QAAAA,SAAS,GAAGL,QAAZ;AACAA,QAAAA,QAAQ,GAAGG,KAAX;AACD;;AACD,UAAIE,SAAS,IAAIA,SAAS,KAAKF,KAA/B,EAAsC;AACpCN,QAAAA,EAAE,CAACS,OAAH,CAAWD,SAAX,EAAsBF,KAAtB;AACA;AACD;;AACDA,MAAAA,KAAK,GAAGC,MAAR;AACD;AACF,GAnBD;AAqBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACC","sourcesContent":["var _ = require(\"../lodash\");\r\n\r\nmodule.exports = addSubgraphConstraints;\r\n\r\nfunction addSubgraphConstraints(g, cg, vs) {\r\n  var prev = {},\r\n    rootPrev;\r\n\r\n  _.forEach(vs, function(v) {\r\n    var child = g.parent(v),\r\n      parent,\r\n      prevChild;\r\n    while (child) {\r\n      parent = g.parent(child);\r\n      if (parent) {\r\n        prevChild = prev[parent];\r\n        prev[parent] = child;\r\n      } else {\r\n        prevChild = rootPrev;\r\n        rootPrev = child;\r\n      }\r\n      if (prevChild && prevChild !== child) {\r\n        cg.setEdge(prevChild, child);\r\n        return;\r\n      }\r\n      child = parent;\r\n    }\r\n  });\r\n\r\n  /*\r\n  function dfs(v) {\r\n    var children = v ? g.children(v) : g.children();\r\n    if (children.length) {\r\n      var min = Number.POSITIVE_INFINITY,\r\n          subgraphs = [];\r\n      _.each(children, function(child) {\r\n        var childMin = dfs(child);\r\n        if (g.children(child).length) {\r\n          subgraphs.push({ v: child, order: childMin });\r\n        }\r\n        min = Math.min(min, childMin);\r\n      });\r\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\r\n        cg.setEdge(prev.v, curr.v);\r\n        return curr;\r\n      });\r\n      return min;\r\n    }\r\n    return g.node(v).order;\r\n  }\r\n  dfs(undefined);\r\n  */\r\n}\r\n"]},"metadata":{},"sourceType":"script"}