{"ast":null,"code":"// @ts-nocheck\n\n/**\r\n * @fileOverview fruchterman layout\r\n * @author shiwu.wyy@antfin.com\r\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\"; // @ts-ignore\n\nimport { World } from \"@antv/g-webgpu\"; // compile at runtime in dev mode\n\nimport { buildTextureData, attributesToTextureData } from \"../../util/gpu\"; // use compiled bundle in prod mode\n\nimport { fruchtermanBundle, clusterBundle } from \"./fruchtermanShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\r\n * fruchterman 布局\r\n */\n\nexport class FruchtermanGPULayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 重力大小，影响图的紧凑程度 */\n\n    this.gravity = 10;\n    /** 速度 */\n\n    this.speed = 1;\n    /** 是否产生聚类力 */\n\n    this.clustering = false;\n    /** 根据哪个字段聚类 */\n\n    this.clusterField = \"cluster\";\n    /** 聚类力大小 */\n\n    this.clusterGravity = 10;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n  /**\r\n   * 执行布局\r\n   */\n\n\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      const center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * this.width;\n        if (!isNumber(node.y)) node.y = Math.random() * this.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      yield self.run();\n    });\n  }\n\n  executeWithWorker(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const center = self.center;\n\n      if (!nodes || nodes.length === 0) {\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * this.width;\n        if (!isNumber(node.y)) node.y = Math.random() * this.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      yield self.run(canvas, ctx);\n    });\n  }\n\n  run(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const edges = self.edges;\n      const maxIteration = self.maxIteration;\n      const center = self.center;\n      const area = self.height * self.width;\n      let maxDisplace = Math.sqrt(area) / 10;\n      const k2 = area / (nodes.length + 1);\n      const k = Math.sqrt(k2);\n      const speed = self.speed;\n      const clustering = self.clustering;\n      const {\n        array: attributeArray,\n        count: clusterCount\n      } = attributesToTextureData([self.clusterField], nodes); // pushing the fx and fy\n\n      nodes.forEach((node, i) => {\n        let fx = 0;\n        let fy = 0;\n\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          fx = node.fx || 0.001;\n          fy = node.fy || 0.001;\n        }\n\n        attributeArray[4 * i + 1] = fx;\n        attributeArray[4 * i + 2] = fy;\n      });\n      const numParticles = nodes.length;\n      const {\n        maxEdgePerVetex,\n        array: nodesEdgesArray\n      } = buildTextureData(nodes, edges);\n      const workerEnabled = self.workerEnabled;\n      let world;\n\n      if (workerEnabled) {\n        world = World.create({\n          canvas,\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } else {\n        world = World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } // compile at runtime in dev mode\n      // const compiler = new Compiler()\n      // const fruchtermanBundle = compiler.compileBundle(fruchtermanCode)\n      // const clusterBundle = compiler.compileBundle(clusterCode)\n      // use compiled bundle in prod mode\n      // console.log(fruchtermanBundle.toString())\n      // console.log(clusterBundle.toString())\n\n\n      const onLayoutEnd = self.onLayoutEnd;\n      const clusterCenters = [];\n\n      for (let i = 0; i < clusterCount; i++) {\n        clusterCenters.push(0, 0, 0, 0);\n      }\n\n      const kernelFruchterman = world.createKernel(fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        u_K: k,\n        u_K2: k2,\n        u_Gravity: self.gravity,\n        u_ClusterGravity: self.clusterGravity || self.gravity || 1,\n        u_Speed: speed,\n        u_MaxDisplace: maxDisplace,\n        u_Clustering: clustering ? 1 : 0,\n        u_Center: center,\n        u_AttributeArray: attributeArray,\n        u_ClusterCenters: clusterCenters,\n        MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n        VERTEX_COUNT: numParticles\n      });\n      let kernelCluster;\n\n      if (clustering) {\n        kernelCluster = world.createKernel(clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_NodeAttributes: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          VERTEX_COUNT: numParticles,\n          CLUSTER_COUNT: clusterCount\n        });\n      }\n\n      const execute = () => __awaiter(this, void 0, void 0, function* () {\n        for (let i = 0; i < maxIteration; i++) {\n          // eslint-disable-next-line no-await-in-loop\n          yield kernelFruchterman.execute();\n\n          if (clustering) {\n            kernelCluster.setBinding({\n              u_Data: kernelFruchterman\n            }); // eslint-disable-next-line no-await-in-loop\n\n            yield kernelCluster.execute();\n            kernelFruchterman.setBinding({\n              u_ClusterCenters: kernelCluster\n            });\n          }\n\n          kernelFruchterman.setBinding({\n            u_MaxDisplace: maxDisplace *= 0.99\n          });\n        }\n\n        const finalParticleData = yield kernelFruchterman.getOutput();\n\n        if (canvas) {\n          // 传递数据给主线程\n          ctx.postMessage({\n            type: LAYOUT_MESSAGE.GPUEND,\n            vertexEdgeData: finalParticleData // edgeIndexBufferData,\n\n          });\n        } else {\n          nodes.forEach((node, i) => {\n            const x = finalParticleData[4 * i];\n            const y = finalParticleData[4 * i + 1];\n            node.x = x;\n            node.y = y;\n          });\n        }\n\n        if (onLayoutEnd) onLayoutEnd();\n      });\n\n      yield execute();\n    });\n  }\n\n  getType() {\n    return \"fruchterman-gpu\";\n  }\n\n}","map":{"version":3,"sources":["../../../src/layout/gpu/fruchterman.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-nocheck\r\n/**\r\n * @fileOverview fruchterman layout\r\n * @author shiwu.wyy@antfin.com\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { Base } from \"../base\";\r\nimport { isNumber } from \"../../util\";\r\n// @ts-ignore\r\nimport { World } from \"@antv/g-webgpu\";\r\n// compile at runtime in dev mode\r\nimport { buildTextureData, attributesToTextureData } from \"../../util/gpu\";\r\n// use compiled bundle in prod mode\r\nimport { fruchtermanBundle, clusterBundle } from \"./fruchtermanShader\";\r\nimport { LAYOUT_MESSAGE } from \"../constants\";\r\n/**\r\n * fruchterman 布局\r\n */\r\nexport class FruchtermanGPULayout extends Base {\r\n    constructor(options) {\r\n        super();\r\n        /** 停止迭代的最大迭代数 */\r\n        this.maxIteration = 1000;\r\n        /** 重力大小，影响图的紧凑程度 */\r\n        this.gravity = 10;\r\n        /** 速度 */\r\n        this.speed = 1;\r\n        /** 是否产生聚类力 */\r\n        this.clustering = false;\r\n        /** 根据哪个字段聚类 */\r\n        this.clusterField = \"cluster\";\r\n        /** 聚类力大小 */\r\n        this.clusterGravity = 10;\r\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\r\n        this.workerEnabled = false;\r\n        this.nodes = [];\r\n        this.edges = [];\r\n        this.width = 300;\r\n        this.height = 300;\r\n        this.nodeMap = {};\r\n        this.nodeIdxMap = {};\r\n        this.updateCfg(options);\r\n    }\r\n    getDefaultCfg() {\r\n        return {\r\n            maxIteration: 1000,\r\n            gravity: 10,\r\n            speed: 1,\r\n            clustering: false,\r\n            clusterGravity: 10\r\n        };\r\n    }\r\n    /**\r\n     * 执行布局\r\n     */\r\n    execute() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const self = this;\r\n            const nodes = self.nodes;\r\n            if (!nodes || nodes.length === 0) {\r\n                if (self.onLayoutEnd)\r\n                    self.onLayoutEnd();\r\n                return;\r\n            }\r\n            if (!self.width && typeof window !== \"undefined\") {\r\n                self.width = window.innerWidth;\r\n            }\r\n            if (!self.height && typeof window !== \"undefined\") {\r\n                self.height = window.innerHeight;\r\n            }\r\n            if (!self.center) {\r\n                self.center = [self.width / 2, self.height / 2];\r\n            }\r\n            const center = self.center;\r\n            if (nodes.length === 1) {\r\n                nodes[0].x = center[0];\r\n                nodes[0].y = center[1];\r\n                if (self.onLayoutEnd)\r\n                    self.onLayoutEnd();\r\n                return;\r\n            }\r\n            const nodeMap = {};\r\n            const nodeIdxMap = {};\r\n            nodes.forEach((node, i) => {\r\n                if (!isNumber(node.x))\r\n                    node.x = Math.random() * this.width;\r\n                if (!isNumber(node.y))\r\n                    node.y = Math.random() * this.height;\r\n                nodeMap[node.id] = node;\r\n                nodeIdxMap[node.id] = i;\r\n            });\r\n            self.nodeMap = nodeMap;\r\n            self.nodeIdxMap = nodeIdxMap;\r\n            // layout\r\n            yield self.run();\r\n        });\r\n    }\r\n    executeWithWorker(canvas, ctx) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const self = this;\r\n            const nodes = self.nodes;\r\n            const center = self.center;\r\n            if (!nodes || nodes.length === 0) {\r\n                return;\r\n            }\r\n            if (nodes.length === 1) {\r\n                nodes[0].x = center[0];\r\n                nodes[0].y = center[1];\r\n                return;\r\n            }\r\n            const nodeMap = {};\r\n            const nodeIdxMap = {};\r\n            nodes.forEach((node, i) => {\r\n                if (!isNumber(node.x))\r\n                    node.x = Math.random() * this.width;\r\n                if (!isNumber(node.y))\r\n                    node.y = Math.random() * this.height;\r\n                nodeMap[node.id] = node;\r\n                nodeIdxMap[node.id] = i;\r\n            });\r\n            self.nodeMap = nodeMap;\r\n            self.nodeIdxMap = nodeIdxMap;\r\n            // layout\r\n            yield self.run(canvas, ctx);\r\n        });\r\n    }\r\n    run(canvas, ctx) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const self = this;\r\n            const nodes = self.nodes;\r\n            const edges = self.edges;\r\n            const maxIteration = self.maxIteration;\r\n            const center = self.center;\r\n            const area = self.height * self.width;\r\n            let maxDisplace = Math.sqrt(area) / 10;\r\n            const k2 = area / (nodes.length + 1);\r\n            const k = Math.sqrt(k2);\r\n            const speed = self.speed;\r\n            const clustering = self.clustering;\r\n            const { array: attributeArray, count: clusterCount } = attributesToTextureData([self.clusterField], nodes);\r\n            // pushing the fx and fy\r\n            nodes.forEach((node, i) => {\r\n                let fx = 0;\r\n                let fy = 0;\r\n                if (isNumber(node.fx) && isNumber(node.fy)) {\r\n                    fx = node.fx || 0.001;\r\n                    fy = node.fy || 0.001;\r\n                }\r\n                attributeArray[4 * i + 1] = fx;\r\n                attributeArray[4 * i + 2] = fy;\r\n            });\r\n            const numParticles = nodes.length;\r\n            const { maxEdgePerVetex, array: nodesEdgesArray } = buildTextureData(nodes, edges);\r\n            const workerEnabled = self.workerEnabled;\r\n            let world;\r\n            if (workerEnabled) {\r\n                world = World.create({\r\n                    canvas,\r\n                    engineOptions: {\r\n                        supportCompute: true\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                world = World.create({\r\n                    engineOptions: {\r\n                        supportCompute: true\r\n                    }\r\n                });\r\n            }\r\n            // compile at runtime in dev mode\r\n            // const compiler = new Compiler()\r\n            // const fruchtermanBundle = compiler.compileBundle(fruchtermanCode)\r\n            // const clusterBundle = compiler.compileBundle(clusterCode)\r\n            // use compiled bundle in prod mode\r\n            // console.log(fruchtermanBundle.toString())\r\n            // console.log(clusterBundle.toString())\r\n            const onLayoutEnd = self.onLayoutEnd;\r\n            const clusterCenters = [];\r\n            for (let i = 0; i < clusterCount; i++) {\r\n                clusterCenters.push(0, 0, 0, 0);\r\n            }\r\n            const kernelFruchterman = world\r\n                .createKernel(fruchtermanBundle)\r\n                .setDispatch([numParticles, 1, 1])\r\n                .setBinding({\r\n                u_Data: nodesEdgesArray,\r\n                u_K: k,\r\n                u_K2: k2,\r\n                u_Gravity: self.gravity,\r\n                u_ClusterGravity: self.clusterGravity || self.gravity || 1,\r\n                u_Speed: speed,\r\n                u_MaxDisplace: maxDisplace,\r\n                u_Clustering: clustering ? 1 : 0,\r\n                u_Center: center,\r\n                u_AttributeArray: attributeArray,\r\n                u_ClusterCenters: clusterCenters,\r\n                MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\r\n                VERTEX_COUNT: numParticles\r\n            });\r\n            let kernelCluster;\r\n            if (clustering) {\r\n                kernelCluster = world\r\n                    .createKernel(clusterBundle)\r\n                    .setDispatch([clusterCount, 1, 1])\r\n                    .setBinding({\r\n                    u_Data: nodesEdgesArray,\r\n                    u_NodeAttributes: attributeArray,\r\n                    u_ClusterCenters: clusterCenters,\r\n                    VERTEX_COUNT: numParticles,\r\n                    CLUSTER_COUNT: clusterCount\r\n                });\r\n            }\r\n            const execute = () => __awaiter(this, void 0, void 0, function* () {\r\n                for (let i = 0; i < maxIteration; i++) {\r\n                    // eslint-disable-next-line no-await-in-loop\r\n                    yield kernelFruchterman.execute();\r\n                    if (clustering) {\r\n                        kernelCluster.setBinding({\r\n                            u_Data: kernelFruchterman\r\n                        });\r\n                        // eslint-disable-next-line no-await-in-loop\r\n                        yield kernelCluster.execute();\r\n                        kernelFruchterman.setBinding({\r\n                            u_ClusterCenters: kernelCluster\r\n                        });\r\n                    }\r\n                    kernelFruchterman.setBinding({\r\n                        u_MaxDisplace: maxDisplace *= 0.99\r\n                    });\r\n                }\r\n                const finalParticleData = yield kernelFruchterman.getOutput();\r\n                if (canvas) {\r\n                    // 传递数据给主线程\r\n                    ctx.postMessage({\r\n                        type: LAYOUT_MESSAGE.GPUEND,\r\n                        vertexEdgeData: finalParticleData\r\n                        // edgeIndexBufferData,\r\n                    });\r\n                }\r\n                else {\r\n                    nodes.forEach((node, i) => {\r\n                        const x = finalParticleData[4 * i];\r\n                        const y = finalParticleData[4 * i + 1];\r\n                        node.x = x;\r\n                        node.y = y;\r\n                    });\r\n                }\r\n                if (onLayoutEnd)\r\n                    onLayoutEnd();\r\n            });\r\n            yield execute();\r\n        });\r\n    }\r\n    getType() {\r\n        return \"fruchterman-gpu\";\r\n    }\r\n}\r\n//# sourceMappingURL=fruchterman.js.map"]},"metadata":{},"sourceType":"module"}