{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = crossCount;\n/*\r\n * A function that takes a layering (an array of layers, each with an array of\r\n * ordererd nodes) and a graph and returns a weighted crossing count.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Input graph must be simple (not a multigraph), directed, and include\r\n *       only simple edges.\r\n *    2. Edges in the input graph must have assigned weights.\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. The graph and layering matrix are left unchanged.\r\n *\r\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\r\n */\n\nfunction crossCount(g, layering) {\n  var cc = 0;\n\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer, _.map(southLayer, function (v, i) {\n    return i;\n  }));\n\n  var southEntries = _.flatten(_.map(northLayer, function (v) {\n    return _.sortBy(_.map(g.outEdges(v), function (e) {\n      return {\n        pos: southPos[e.w],\n        weight: g.edge(e).weight\n      };\n    }), \"pos\");\n  }), true); // Build the accumulator tree\n\n\n  var firstIndex = 1;\n\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  }); // Calculate the weighted crossings\n\n\n  var cc = 0;\n\n  _.forEach(southEntries.forEach(function (entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}","map":{"version":3,"sources":["D:/SQL/sqlindex2/sql/frontend/node_modules/dagre/lib/order/cross-count.js"],"names":["_","require","module","exports","crossCount","g","layering","cc","i","length","twoLayerCrossCount","northLayer","southLayer","southPos","zipObject","map","v","southEntries","flatten","sortBy","outEdges","e","pos","w","weight","edge","firstIndex","treeSize","tree","Array","forEach","entry","index","weightSum"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,WAAD,CAAf;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,UAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,UAAT,CAAoBC,CAApB,EAAuBC,QAAvB,EAAiC;AAC/B,MAAIC,EAAE,GAAG,CAAT;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACG,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;AACxCD,IAAAA,EAAE,IAAIG,kBAAkB,CAACL,CAAD,EAAIC,QAAQ,CAACE,CAAC,GAAC,CAAH,CAAZ,EAAmBF,QAAQ,CAACE,CAAD,CAA3B,CAAxB;AACD;;AACD,SAAOD,EAAP;AACD;;AAED,SAASG,kBAAT,CAA4BL,CAA5B,EAA+BM,UAA/B,EAA2CC,UAA3C,EAAuD;AACrD;AACA;AACA;AACA,MAAIC,QAAQ,GAAGb,CAAC,CAACc,SAAF,CAAYF,UAAZ,EACbZ,CAAC,CAACe,GAAF,CAAMH,UAAN,EAAkB,UAAUI,CAAV,EAAaR,CAAb,EAAgB;AAAE,WAAOA,CAAP;AAAW,GAA/C,CADa,CAAf;;AAEA,MAAIS,YAAY,GAAGjB,CAAC,CAACkB,OAAF,CAAUlB,CAAC,CAACe,GAAF,CAAMJ,UAAN,EAAkB,UAASK,CAAT,EAAY;AACzD,WAAOhB,CAAC,CAACmB,MAAF,CAASnB,CAAC,CAACe,GAAF,CAAMV,CAAC,CAACe,QAAF,CAAWJ,CAAX,CAAN,EAAqB,UAASK,CAAT,EAAY;AAC/C,aAAO;AAAEC,QAAAA,GAAG,EAAET,QAAQ,CAACQ,CAAC,CAACE,CAAH,CAAf;AAAsBC,QAAAA,MAAM,EAAEnB,CAAC,CAACoB,IAAF,CAAOJ,CAAP,EAAUG;AAAxC,OAAP;AACD,KAFe,CAAT,EAEH,KAFG,CAAP;AAGD,GAJ4B,CAAV,EAIf,IAJe,CAAnB,CANqD,CAYrD;;;AACA,MAAIE,UAAU,GAAG,CAAjB;;AACA,SAAOA,UAAU,GAAGd,UAAU,CAACH,MAA/B,EAAuCiB,UAAU,KAAK,CAAf;;AACvC,MAAIC,QAAQ,GAAG,IAAID,UAAJ,GAAiB,CAAhC;AACAA,EAAAA,UAAU,IAAI,CAAd;;AACA,MAAIE,IAAI,GAAG5B,CAAC,CAACe,GAAF,CAAM,IAAIc,KAAJ,CAAUF,QAAV,CAAN,EAA2B,YAAW;AAAE,WAAO,CAAP;AAAW,GAAnD,CAAX,CAjBqD,CAmBrD;;;AACA,MAAIpB,EAAE,GAAG,CAAT;;AACAP,EAAAA,CAAC,CAAC8B,OAAF,CAAUb,YAAY,CAACa,OAAb,CAAqB,UAASC,KAAT,EAAgB;AAC7C,QAAIC,KAAK,GAAGD,KAAK,CAACT,GAAN,GAAYI,UAAxB;AACAE,IAAAA,IAAI,CAACI,KAAD,CAAJ,IAAeD,KAAK,CAACP,MAArB;AACA,QAAIS,SAAS,GAAG,CAAhB;;AACA,WAAOD,KAAK,GAAG,CAAf,EAAkB;AAChB,UAAIA,KAAK,GAAG,CAAZ,EAAe;AACbC,QAAAA,SAAS,IAAIL,IAAI,CAACI,KAAK,GAAG,CAAT,CAAjB;AACD;;AACDA,MAAAA,KAAK,GAAIA,KAAK,GAAG,CAAT,IAAe,CAAvB;AACAJ,MAAAA,IAAI,CAACI,KAAD,CAAJ,IAAeD,KAAK,CAACP,MAArB;AACD;;AACDjB,IAAAA,EAAE,IAAIwB,KAAK,CAACP,MAAN,GAAeS,SAArB;AACD,GAZS,CAAV;;AAcA,SAAO1B,EAAP;AACD","sourcesContent":["\"use strict\";\r\n\r\nvar _ = require(\"../lodash\");\r\n\r\nmodule.exports = crossCount;\r\n\r\n/*\r\n * A function that takes a layering (an array of layers, each with an array of\r\n * ordererd nodes) and a graph and returns a weighted crossing count.\r\n *\r\n * Pre-conditions:\r\n *\r\n *    1. Input graph must be simple (not a multigraph), directed, and include\r\n *       only simple edges.\r\n *    2. Edges in the input graph must have assigned weights.\r\n *\r\n * Post-conditions:\r\n *\r\n *    1. The graph and layering matrix are left unchanged.\r\n *\r\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\r\n */\r\nfunction crossCount(g, layering) {\r\n  var cc = 0;\r\n  for (var i = 1; i < layering.length; ++i) {\r\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\r\n  }\r\n  return cc;\r\n}\r\n\r\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\r\n  // Sort all of the edges between the north and south layers by their position\r\n  // in the north layer and then the south. Map these edges to the position of\r\n  // their head in the south layer.\r\n  var southPos = _.zipObject(southLayer,\r\n    _.map(southLayer, function (v, i) { return i; }));\r\n  var southEntries = _.flatten(_.map(northLayer, function(v) {\r\n    return _.sortBy(_.map(g.outEdges(v), function(e) {\r\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\r\n    }), \"pos\");\r\n  }), true);\r\n\r\n  // Build the accumulator tree\r\n  var firstIndex = 1;\r\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\r\n  var treeSize = 2 * firstIndex - 1;\r\n  firstIndex -= 1;\r\n  var tree = _.map(new Array(treeSize), function() { return 0; });\r\n\r\n  // Calculate the weighted crossings\r\n  var cc = 0;\r\n  _.forEach(southEntries.forEach(function(entry) {\r\n    var index = entry.pos + firstIndex;\r\n    tree[index] += entry.weight;\r\n    var weightSum = 0;\r\n    while (index > 0) {\r\n      if (index % 2) {\r\n        weightSum += tree[index + 1];\r\n      }\r\n      index = (index - 1) >> 1;\r\n      tree[index] += entry.weight;\r\n    }\r\n    cc += entry.weight * weightSum;\r\n  }));\r\n\r\n  return cc;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}