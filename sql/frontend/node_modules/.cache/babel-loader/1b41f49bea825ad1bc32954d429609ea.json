{"ast":null,"code":"import { getNeighbors } from \"./util\";\n/**\r\n * Generate all connected components for an undirected graph\r\n * @param graph\r\n */\n\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = getNeighbors(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\r\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\r\n * For directed graph only\r\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\r\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n * @param graph\r\n * @return a list of strongly connected components\r\n */\n\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\nexport default function getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/@antv/algorithm/es/connected-component.js"],"names":["getNeighbors","detectConnectedComponents","graphData","_a","nodes","_b","edges","allComponents","visited","nodeStack","getComponent","node","push","id","neighbors","_loop_1","i","neighbor","targetNode","filter","length","component","pop","detectStrongConnectComponents","inStack","indices","lowLink","index","n","map","indexOf","_loop_2","targetNodeID","Math","min","tmpNode","_i","nodes_1","getConnectedComponents","directed"],"mappings":"AAAA,SAASA,YAAT,QAA6B,QAA7B;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,yBAAyB,GAAG,SAASA,yBAAT,CAAmCC,SAAnC,EAA8C;AACnF,MAAIC,EAAE,GAAGD,SAAS,CAACE,KAAnB;AAAA,MACIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EADjC;AAAA,MAEIE,EAAE,GAAGH,SAAS,CAACI,KAFnB;AAAA,MAGIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAHjC;AAIA,MAAIE,aAAa,GAAG,EAApB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAIC,YAAY,GAAG,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC7CF,IAAAA,SAAS,CAACG,IAAV,CAAeD,IAAf;AACAH,IAAAA,OAAO,CAACG,IAAI,CAACE,EAAN,CAAP,GAAmB,IAAnB;AACA,QAAIC,SAAS,GAAGd,YAAY,CAACW,IAAI,CAACE,EAAN,EAAUP,KAAV,CAA5B;;AAEA,QAAIS,OAAO,GAAG,SAASA,OAAT,CAAiBC,CAAjB,EAAoB;AAChC,UAAIC,QAAQ,GAAGH,SAAS,CAACE,CAAD,CAAxB;;AAEA,UAAI,CAACR,OAAO,CAACS,QAAD,CAAZ,EAAwB;AACtB,YAAIC,UAAU,GAAGd,KAAK,CAACe,MAAN,CAAa,UAAUR,IAAV,EAAgB;AAC5C,iBAAOA,IAAI,CAACE,EAAL,KAAYI,QAAnB;AACD,SAFgB,CAAjB;;AAIA,YAAIC,UAAU,CAACE,MAAX,GAAoB,CAAxB,EAA2B;AACzBV,UAAAA,YAAY,CAACQ,UAAU,CAAC,CAAD,CAAX,CAAZ;AACD;AACF;AACF,KAZD;;AAcA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACM,MAA9B,EAAsC,EAAEJ,CAAxC,EAA2C;AACzCD,MAAAA,OAAO,CAACC,CAAD,CAAP;AACD;AACF,GAtBD;;AAwBA,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,KAAK,CAACgB,MAA1B,EAAkCJ,CAAC,EAAnC,EAAuC;AACrC,QAAIL,IAAI,GAAGP,KAAK,CAACY,CAAD,CAAhB;;AAEA,QAAI,CAACR,OAAO,CAACG,IAAI,CAACE,EAAN,CAAZ,EAAuB;AACrB;AACAH,MAAAA,YAAY,CAACC,IAAD,CAAZ;AACA,UAAIU,SAAS,GAAG,EAAhB;;AAEA,aAAOZ,SAAS,CAACW,MAAV,GAAmB,CAA1B,EAA6B;AAC3BC,QAAAA,SAAS,CAACT,IAAV,CAAeH,SAAS,CAACa,GAAV,EAAf;AACD;;AAEDf,MAAAA,aAAa,CAACK,IAAd,CAAmBS,SAAnB;AACD;AACF;;AAED,SAAOd,aAAP;AACD,CAlDM;AAmDP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIgB,6BAA6B,GAAG,SAASA,6BAAT,CAAuCrB,SAAvC,EAAkD;AAC3F,MAAIC,EAAE,GAAGD,SAAS,CAACE,KAAnB;AAAA,MACIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EADjC;AAAA,MAEIE,EAAE,GAAGH,SAAS,CAACI,KAFnB;AAAA,MAGIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAHjC;AAIA,MAAII,SAAS,GAAG,EAAhB;AACA,MAAIe,OAAO,GAAG,EAAd,CAN2F,CAMzE;;AAElB,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAInB,aAAa,GAAG,EAApB;AACA,MAAIoB,KAAK,GAAG,CAAZ;;AAEA,MAAIjB,YAAY,GAAG,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC7C;AACAc,IAAAA,OAAO,CAACd,IAAI,CAACE,EAAN,CAAP,GAAmBc,KAAnB;AACAD,IAAAA,OAAO,CAACf,IAAI,CAACE,EAAN,CAAP,GAAmBc,KAAnB;AACAA,IAAAA,KAAK,IAAI,CAAT;AACAlB,IAAAA,SAAS,CAACG,IAAV,CAAeD,IAAf;AACAa,IAAAA,OAAO,CAACb,IAAI,CAACE,EAAN,CAAP,GAAmB,IAAnB,CAN6C,CAMpB;;AAEzB,QAAIC,SAAS,GAAGd,YAAY,CAACW,IAAI,CAACE,EAAN,EAAUP,KAAV,EAAiB,QAAjB,CAAZ,CAAuCa,MAAvC,CAA8C,UAAUS,CAAV,EAAa;AACzE,aAAOxB,KAAK,CAACyB,GAAN,CAAU,UAAUlB,IAAV,EAAgB;AAC/B,eAAOA,IAAI,CAACE,EAAZ;AACD,OAFM,EAEJiB,OAFI,CAEIF,CAFJ,IAES,CAAC,CAFjB;AAGD,KAJe,CAAhB;;AAMA,QAAIG,OAAO,GAAG,SAASA,OAAT,CAAiBf,CAAjB,EAAoB;AAChC,UAAIgB,YAAY,GAAGlB,SAAS,CAACE,CAAD,CAA5B;;AAEA,UAAI,CAACS,OAAO,CAACO,YAAD,CAAR,IAA0BP,OAAO,CAACO,YAAD,CAAP,KAA0B,CAAxD,EAA2D;AACzD,YAAId,UAAU,GAAGd,KAAK,CAACe,MAAN,CAAa,UAAUR,IAAV,EAAgB;AAC5C,iBAAOA,IAAI,CAACE,EAAL,KAAYmB,YAAnB;AACD,SAFgB,CAAjB;;AAIA,YAAId,UAAU,CAACE,MAAX,GAAoB,CAAxB,EAA2B;AACzBV,UAAAA,YAAY,CAACQ,UAAU,CAAC,CAAD,CAAX,CAAZ;AACD,SAPwD,CAOvD;;;AAGFQ,QAAAA,OAAO,CAACf,IAAI,CAACE,EAAN,CAAP,GAAmBoB,IAAI,CAACC,GAAL,CAASR,OAAO,CAACf,IAAI,CAACE,EAAN,CAAhB,EAA2Ba,OAAO,CAACM,YAAD,CAAlC,CAAnB;AACD,OAXD,MAWO,IAAIR,OAAO,CAACQ,YAAD,CAAX,EAA2B;AAChC;AACAN,QAAAA,OAAO,CAACf,IAAI,CAACE,EAAN,CAAP,GAAmBoB,IAAI,CAACC,GAAL,CAASR,OAAO,CAACf,IAAI,CAACE,EAAN,CAAhB,EAA2BY,OAAO,CAACO,YAAD,CAAlC,CAAnB;AACD;AACF,KAlBD;;AAoBA,SAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACM,MAA9B,EAAsCJ,CAAC,EAAvC,EAA2C;AACzCe,MAAAA,OAAO,CAACf,CAAD,CAAP;AACD,KApC4C,CAoC3C;;;AAGF,QAAIU,OAAO,CAACf,IAAI,CAACE,EAAN,CAAP,KAAqBY,OAAO,CAACd,IAAI,CAACE,EAAN,CAAhC,EAA2C;AACzC,UAAIQ,SAAS,GAAG,EAAhB;;AAEA,aAAOZ,SAAS,CAACW,MAAV,GAAmB,CAA1B,EAA6B;AAC3B,YAAIe,OAAO,GAAG1B,SAAS,CAACa,GAAV,EAAd;AACAE,QAAAA,OAAO,CAACW,OAAO,CAACtB,EAAT,CAAP,GAAsB,KAAtB;AACAQ,QAAAA,SAAS,CAACT,IAAV,CAAeuB,OAAf;AACA,YAAIA,OAAO,KAAKxB,IAAhB,EAAsB;AACvB;;AAED,UAAIU,SAAS,CAACD,MAAV,GAAmB,CAAvB,EAA0B;AACxBb,QAAAA,aAAa,CAACK,IAAd,CAAmBS,SAAnB;AACD;AACF;AACF,GArDD;;AAuDA,OAAK,IAAIe,EAAE,GAAG,CAAT,EAAYC,OAAO,GAAGjC,KAA3B,EAAkCgC,EAAE,GAAGC,OAAO,CAACjB,MAA/C,EAAuDgB,EAAE,EAAzD,EAA6D;AAC3D,QAAIzB,IAAI,GAAG0B,OAAO,CAACD,EAAD,CAAlB;;AAEA,QAAI,CAACX,OAAO,CAACd,IAAI,CAACE,EAAN,CAAR,IAAqBY,OAAO,CAACd,IAAI,CAACE,EAAN,CAAP,KAAqB,CAA9C,EAAiD;AAC/CH,MAAAA,YAAY,CAACC,IAAD,CAAZ;AACD;AACF;;AAED,SAAOJ,aAAP;AACD,CA7EM;AA8EP,eAAe,SAAS+B,sBAAT,CAAgCpC,SAAhC,EAA2CqC,QAA3C,EAAqD;AAClE,MAAIA,QAAJ,EAAc,OAAOhB,6BAA6B,CAACrB,SAAD,CAApC;AACd,SAAOD,yBAAyB,CAACC,SAAD,CAAhC;AACD","sourcesContent":["import { getNeighbors } from \"./util\";\r\n/**\r\n * Generate all connected components for an undirected graph\r\n * @param graph\r\n */\r\n\r\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var allComponents = [];\r\n  var visited = {};\r\n  var nodeStack = [];\r\n\r\n  var getComponent = function getComponent(node) {\r\n    nodeStack.push(node);\r\n    visited[node.id] = true;\r\n    var neighbors = getNeighbors(node.id, edges);\r\n\r\n    var _loop_1 = function _loop_1(i) {\r\n      var neighbor = neighbors[i];\r\n\r\n      if (!visited[neighbor]) {\r\n        var targetNode = nodes.filter(function (node) {\r\n          return node.id === neighbor;\r\n        });\r\n\r\n        if (targetNode.length > 0) {\r\n          getComponent(targetNode[0]);\r\n        }\r\n      }\r\n    };\r\n\r\n    for (var i = 0; i < neighbors.length; ++i) {\r\n      _loop_1(i);\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    var node = nodes[i];\r\n\r\n    if (!visited[node.id]) {\r\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\r\n      getComponent(node);\r\n      var component = [];\r\n\r\n      while (nodeStack.length > 0) {\r\n        component.push(nodeStack.pop());\r\n      }\r\n\r\n      allComponents.push(component);\r\n    }\r\n  }\r\n\r\n  return allComponents;\r\n};\r\n/**\r\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\r\n * For directed graph only\r\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\r\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n * @param graph\r\n * @return a list of strongly connected components\r\n */\r\n\r\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var nodeStack = [];\r\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\r\n\r\n  var indices = {};\r\n  var lowLink = {};\r\n  var allComponents = [];\r\n  var index = 0;\r\n\r\n  var getComponent = function getComponent(node) {\r\n    // Set the depth index for v to the smallest unused index\r\n    indices[node.id] = index;\r\n    lowLink[node.id] = index;\r\n    index += 1;\r\n    nodeStack.push(node);\r\n    inStack[node.id] = true; // 考虑每个邻接点\r\n\r\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\r\n      return nodes.map(function (node) {\r\n        return node.id;\r\n      }).indexOf(n) > -1;\r\n    });\r\n\r\n    var _loop_2 = function _loop_2(i) {\r\n      var targetNodeID = neighbors[i];\r\n\r\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\r\n        var targetNode = nodes.filter(function (node) {\r\n          return node.id === targetNodeID;\r\n        });\r\n\r\n        if (targetNode.length > 0) {\r\n          getComponent(targetNode[0]);\r\n        } // tree edge\r\n\r\n\r\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\r\n      } else if (inStack[targetNodeID]) {\r\n        // back edge, target node is in the current SCC\r\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\r\n      }\r\n    };\r\n\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      _loop_2(i);\r\n    } // If node is a root node, generate an SCC\r\n\r\n\r\n    if (lowLink[node.id] === indices[node.id]) {\r\n      var component = [];\r\n\r\n      while (nodeStack.length > 0) {\r\n        var tmpNode = nodeStack.pop();\r\n        inStack[tmpNode.id] = false;\r\n        component.push(tmpNode);\r\n        if (tmpNode === node) break;\r\n      }\r\n\r\n      if (component.length > 0) {\r\n        allComponents.push(component);\r\n      }\r\n    }\r\n  };\r\n\r\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\r\n    var node = nodes_1[_i];\r\n\r\n    if (!indices[node.id] && indices[node.id] !== 0) {\r\n      getComponent(node);\r\n    }\r\n  }\r\n\r\n  return allComponents;\r\n};\r\nexport default function getConnectedComponents(graphData, directed) {\r\n  if (directed) return detectStrongConnectComponents(graphData);\r\n  return detectConnectedComponents(graphData);\r\n}"]},"metadata":{},"sourceType":"module"}