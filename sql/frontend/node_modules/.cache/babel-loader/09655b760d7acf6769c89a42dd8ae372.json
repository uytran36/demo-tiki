{"ast":null,"code":"var _ = require(\"./lodash\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n} // Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\n\n\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca; // Traverse up from v to find the LCA\n\n  parent = v;\n\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n\n  lca = parent; // Traverse from w to LCA\n\n  parent = w;\n\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return {\n    path: vPath.concat(wPath.reverse()),\n    lca: lca\n  };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n\n    _.forEach(g.children(v), dfs);\n\n    result[v] = {\n      low: low,\n      lim: lim++\n    };\n  }\n\n  _.forEach(g.children(), dfs);\n\n  return result;\n}","map":{"version":3,"sources":["D:/Code/sqlindex2/sql/frontend/node_modules/dagre/lib/parent-dummy-chains.js"],"names":["_","require","module","exports","parentDummyChains","g","postorderNums","postorder","forEach","graph","dummyChains","v","node","edgeObj","pathData","findPath","w","path","lca","pathIdx","pathV","ascending","maxRank","rank","length","minRank","setParent","successors","vPath","wPath","low","Math","min","lim","max","parent","push","concat","reverse","result","dfs","children"],"mappings":"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","sourcesContent":["var _ = require(\"./lodash\");\r\n\r\nmodule.exports = parentDummyChains;\r\n\r\nfunction parentDummyChains(g) {\r\n  var postorderNums = postorder(g);\r\n\r\n  _.forEach(g.graph().dummyChains, function(v) {\r\n    var node = g.node(v);\r\n    var edgeObj = node.edgeObj;\r\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\r\n    var path = pathData.path;\r\n    var lca = pathData.lca;\r\n    var pathIdx = 0;\r\n    var pathV = path[pathIdx];\r\n    var ascending = true;\r\n\r\n    while (v !== edgeObj.w) {\r\n      node = g.node(v);\r\n\r\n      if (ascending) {\r\n        while ((pathV = path[pathIdx]) !== lca &&\r\n               g.node(pathV).maxRank < node.rank) {\r\n          pathIdx++;\r\n        }\r\n\r\n        if (pathV === lca) {\r\n          ascending = false;\r\n        }\r\n      }\r\n\r\n      if (!ascending) {\r\n        while (pathIdx < path.length - 1 &&\r\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\r\n          pathIdx++;\r\n        }\r\n        pathV = path[pathIdx];\r\n      }\r\n\r\n      g.setParent(v, pathV);\r\n      v = g.successors(v)[0];\r\n    }\r\n  });\r\n}\r\n\r\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\r\n// full path and the LCA.\r\nfunction findPath(g, postorderNums, v, w) {\r\n  var vPath = [];\r\n  var wPath = [];\r\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\r\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\r\n  var parent;\r\n  var lca;\r\n\r\n  // Traverse up from v to find the LCA\r\n  parent = v;\r\n  do {\r\n    parent = g.parent(parent);\r\n    vPath.push(parent);\r\n  } while (parent &&\r\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\r\n  lca = parent;\r\n\r\n  // Traverse from w to LCA\r\n  parent = w;\r\n  while ((parent = g.parent(parent)) !== lca) {\r\n    wPath.push(parent);\r\n  }\r\n\r\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\r\n}\r\n\r\nfunction postorder(g) {\r\n  var result = {};\r\n  var lim = 0;\r\n\r\n  function dfs(v) {\r\n    var low = lim;\r\n    _.forEach(g.children(v), dfs);\r\n    result[v] = { low: low, lim: lim++ };\r\n  }\r\n  _.forEach(g.children(), dfs);\r\n\r\n  return result;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}