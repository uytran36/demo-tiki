{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { isArray } from '@antv/util';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath), [target]));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"sources":["E:/sqlindex2/sql/frontend/node_modules/@antv/algorithm/es/dijkstra.js"],"names":["__spreadArray","isArray","getOutEdgesNodeId","getEdgesByNodeId","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath"],"mappings":"AAAA,SAASA,aAAT,QAA8B,OAA9B;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,SAASC,iBAAT,EAA4BC,gBAA5B,QAAoD,QAApD;;AAEA,IAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBC,CAAnB,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAoC;AAClD;AACA,MAAIC,MAAM,GAAGC,QAAb;AACA,MAAIC,OAAJ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,QAAIE,MAAM,GAAGP,KAAK,CAACK,CAAD,CAAL,CAASG,EAAtB;;AAEA,QAAI,CAACP,KAAK,CAACM,MAAD,CAAN,IAAkBR,CAAC,CAACQ,MAAD,CAAD,IAAaL,MAAnC,EAA2C;AACzCA,MAAAA,MAAM,GAAGH,CAAC,CAACQ,MAAD,CAAV;AACAH,MAAAA,OAAO,GAAGJ,KAAK,CAACK,CAAD,CAAf;AACD;AACF;;AAED,SAAOD,OAAP;AACD,CAfD;;AAiBA,IAAIK,QAAQ,GAAG,SAASA,QAAT,CAAkBC,SAAlB,EAA6BC,MAA7B,EAAqCC,QAArC,EAA+CC,kBAA/C,EAAmE;AAChF,MAAIC,EAAE,GAAGJ,SAAS,CAACV,KAAnB;AAAA,MACIA,KAAK,GAAGc,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EADjC;AAAA,MAEIC,EAAE,GAAGL,SAAS,CAACM,KAFnB;AAAA,MAGIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAHjC;AAIA,MAAIE,OAAO,GAAG,EAAd;AACA,MAAIhB,KAAK,GAAG,EAAZ;AACA,MAAIF,CAAC,GAAG,EAAR;AACA,MAAImB,KAAK,GAAG,EAAZ,CARgF,CAQhE;;AAEhBlB,EAAAA,KAAK,CAACmB,OAAN,CAAc,UAAUC,IAAV,EAAgBf,CAAhB,EAAmB;AAC/B,QAAIG,EAAE,GAAGY,IAAI,CAACZ,EAAd;AACAS,IAAAA,OAAO,CAACI,IAAR,CAAab,EAAb;AACAT,IAAAA,CAAC,CAACS,EAAD,CAAD,GAAQL,QAAR;AACA,QAAIK,EAAE,KAAKG,MAAX,EAAmBZ,CAAC,CAACS,EAAD,CAAD,GAAQ,CAAR;AACpB,GALD;AAMA,MAAIc,OAAO,GAAGtB,KAAK,CAACM,MAApB;;AAEA,MAAIiB,OAAO,GAAG,SAASA,OAAT,CAAiBlB,CAAjB,EAAoB;AAChC;AACA,QAAID,OAAO,GAAGN,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAWC,KAAX,CAAvB;AACA,QAAIuB,SAAS,GAAGpB,OAAO,CAACI,EAAxB;AACAP,IAAAA,KAAK,CAACuB,SAAD,CAAL,GAAmB,IAAnB;AACA,QAAIzB,CAAC,CAACyB,SAAD,CAAD,KAAiBrB,QAArB,EAA+B,OAAO,UAAP,CALC,CAKkB;;AAElD,QAAIsB,YAAY,GAAG,EAAnB;AACA,QAAIb,QAAJ,EAAca,YAAY,GAAG7B,iBAAiB,CAAC4B,SAAD,EAAYR,KAAZ,CAAhC,CAAd,KAAsES,YAAY,GAAG5B,gBAAgB,CAAC2B,SAAD,EAAYR,KAAZ,CAA/B;AACtES,IAAAA,YAAY,CAACN,OAAb,CAAqB,UAAUO,IAAV,EAAgB;AACnC,UAAIC,UAAU,GAAGD,IAAI,CAACE,MAAtB;AACA,UAAIC,UAAU,GAAGH,IAAI,CAACf,MAAtB;AACA,UAAImB,CAAC,GAAGH,UAAU,KAAKH,SAAf,GAA2BK,UAA3B,GAAwCF,UAAhD;AACA,UAAII,MAAM,GAAGlB,kBAAkB,IAAIa,IAAI,CAACb,kBAAD,CAA1B,GAAiDa,IAAI,CAACb,kBAAD,CAArD,GAA4E,CAAzF;;AAEA,UAAId,CAAC,CAAC+B,CAAD,CAAD,GAAO/B,CAAC,CAACK,OAAO,CAACI,EAAT,CAAD,GAAgBuB,MAA3B,EAAmC;AACjChC,QAAAA,CAAC,CAAC+B,CAAD,CAAD,GAAO/B,CAAC,CAACK,OAAO,CAACI,EAAT,CAAD,GAAgBuB,MAAvB;AACAb,QAAAA,KAAK,CAACY,CAAD,CAAL,GAAW,CAAC1B,OAAO,CAACI,EAAT,CAAX;AACD,OAHD,MAGO,IAAIT,CAAC,CAAC+B,CAAD,CAAD,KAAS/B,CAAC,CAACK,OAAO,CAACI,EAAT,CAAD,GAAgBuB,MAA7B,EAAqC;AAC1Cb,QAAAA,KAAK,CAACY,CAAD,CAAL,CAAST,IAAT,CAAcjB,OAAO,CAACI,EAAtB;AACD;AACF,KAZD;AAaD,GAtBD;;AAwBA,OAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,OAApB,EAA6BjB,CAAC,EAA9B,EAAkC;AAChCkB,IAAAA,OAAO,CAAClB,CAAD,CAAP;AACD;;AAEDa,EAAAA,KAAK,CAACP,MAAD,CAAL,GAAgB,CAACA,MAAD,CAAhB,CA9CgF,CA8CtD;;AAE1B,MAAIqB,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIJ,MAAT,IAAmB7B,CAAnB,EAAsB;AACpB,QAAIA,CAAC,CAAC6B,MAAD,CAAD,KAAczB,QAAlB,EAA4B;AAC1B8B,MAAAA,YAAY,CAACtB,MAAD,EAASiB,MAAT,EAAiBV,KAAjB,EAAwBc,KAAxB,CAAZ;AACD;AACF,GAtD+E,CAsD9E;;;AAGF,MAAIE,IAAI,GAAG,EAAX;;AAEA,OAAK,IAAIN,MAAT,IAAmBI,KAAnB,EAA0B;AACxBE,IAAAA,IAAI,CAACN,MAAD,CAAJ,GAAeI,KAAK,CAACJ,MAAD,CAAL,CAAc,CAAd,CAAf;AACD;;AAED,SAAO;AACLtB,IAAAA,MAAM,EAAEP,CADH;AAELmC,IAAAA,IAAI,EAAEA,IAFD;AAGLC,IAAAA,OAAO,EAAEH;AAHJ,GAAP;AAKD,CApED;;AAsEA,eAAevB,QAAf;;AAEA,SAASwB,YAAT,CAAsBtB,MAAtB,EAA8BiB,MAA9B,EAAsCV,KAAtC,EAA6CkB,UAA7C,EAAyD;AACvD,MAAIzB,MAAM,KAAKiB,MAAf,EAAuB;AACrB,WAAO,CAACjB,MAAD,CAAP;AACD;;AAED,MAAIyB,UAAU,CAACR,MAAD,CAAd,EAAwB;AACtB,WAAOQ,UAAU,CAACR,MAAD,CAAjB;AACD;;AAED,MAAII,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIK,EAAE,GAAG,CAAT,EAAYvB,EAAE,GAAGI,KAAK,CAACU,MAAD,CAA3B,EAAqCS,EAAE,GAAGvB,EAAE,CAACR,MAA7C,EAAqD+B,EAAE,EAAvD,EAA2D;AACzD,QAAIC,IAAI,GAAGxB,EAAE,CAACuB,EAAD,CAAb;AACA,QAAIE,SAAS,GAAGN,YAAY,CAACtB,MAAD,EAAS2B,IAAT,EAAepB,KAAf,EAAsBkB,UAAtB,CAA5B;AACA,QAAI,CAACG,SAAL,EAAgB;;AAEhB,SAAK,IAAIxB,EAAE,GAAG,CAAT,EAAYyB,WAAW,GAAGD,SAA/B,EAA0CxB,EAAE,GAAGyB,WAAW,CAAClC,MAA3D,EAAmES,EAAE,EAArE,EAAyE;AACvE,UAAI0B,OAAO,GAAGD,WAAW,CAACzB,EAAD,CAAzB;AACA,UAAIpB,OAAO,CAAC8C,OAAD,CAAX,EAAsBT,KAAK,CAACX,IAAN,CAAW3B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK+C,OAAL,CAAd,EAA6B,CAACb,MAAD,CAA7B,CAAxB,EAAtB,KAA2FI,KAAK,CAACX,IAAN,CAAW,CAACoB,OAAD,EAAUb,MAAV,CAAX;AAC5F;AACF;;AAEDQ,EAAAA,UAAU,CAACR,MAAD,CAAV,GAAqBI,KAArB;AACA,SAAOI,UAAU,CAACR,MAAD,CAAjB;AACD","sourcesContent":["import { __spreadArray } from \"tslib\";\r\nimport { isArray } from '@antv/util';\r\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\r\n\r\nvar minVertex = function minVertex(D, nodes, marks) {\r\n  // 找出最小的点\r\n  var minDis = Infinity;\r\n  var minNode;\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    var nodeId = nodes[i].id;\r\n\r\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\r\n      minDis = D[nodeId];\r\n      minNode = nodes[i];\r\n    }\r\n  }\r\n\r\n  return minNode;\r\n};\r\n\r\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var nodeIds = [];\r\n  var marks = {};\r\n  var D = {};\r\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\r\n\r\n  nodes.forEach(function (node, i) {\r\n    var id = node.id;\r\n    nodeIds.push(id);\r\n    D[id] = Infinity;\r\n    if (id === source) D[id] = 0;\r\n  });\r\n  var nodeNum = nodes.length;\r\n\r\n  var _loop_1 = function _loop_1(i) {\r\n    // Process the vertices\r\n    var minNode = minVertex(D, nodes, marks);\r\n    var minNodeId = minNode.id;\r\n    marks[minNodeId] = true;\r\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\r\n\r\n    var relatedEdges = [];\r\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\r\n    relatedEdges.forEach(function (edge) {\r\n      var edgeTarget = edge.target;\r\n      var edgeSource = edge.source;\r\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\r\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\r\n\r\n      if (D[w] > D[minNode.id] + weight) {\r\n        D[w] = D[minNode.id] + weight;\r\n        prevs[w] = [minNode.id];\r\n      } else if (D[w] === D[minNode.id] + weight) {\r\n        prevs[w].push(minNode.id);\r\n      }\r\n    });\r\n  };\r\n\r\n  for (var i = 0; i < nodeNum; i++) {\r\n    _loop_1(i);\r\n  }\r\n\r\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\r\n\r\n  var paths = {};\r\n\r\n  for (var target in D) {\r\n    if (D[target] !== Infinity) {\r\n      findAllPaths(source, target, prevs, paths);\r\n    }\r\n  } // 兼容之前单路径\r\n\r\n\r\n  var path = {};\r\n\r\n  for (var target in paths) {\r\n    path[target] = paths[target][0];\r\n  }\r\n\r\n  return {\r\n    length: D,\r\n    path: path,\r\n    allPath: paths\r\n  };\r\n};\r\n\r\nexport default dijkstra;\r\n\r\nfunction findAllPaths(source, target, prevs, foundPaths) {\r\n  if (source === target) {\r\n    return [source];\r\n  }\r\n\r\n  if (foundPaths[target]) {\r\n    return foundPaths[target];\r\n  }\r\n\r\n  var paths = [];\r\n\r\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\r\n    var prev = _a[_i];\r\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\r\n    if (!prevPaths) return;\r\n\r\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\r\n      var prePath = prevPaths_1[_b];\r\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath), [target]));else paths.push([prePath, target]);\r\n    }\r\n  }\r\n\r\n  foundPaths[target] = paths;\r\n  return foundPaths[target];\r\n}"]},"metadata":{},"sourceType":"module"}